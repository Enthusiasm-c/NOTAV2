============================= test session starts ==============================
platform darwin -- Python 3.9.6, pytest-8.0.0, pluggy-1.5.0 -- /Users/Denis/Documents/NOTA/NOTAV2/.venv/bin/python3
cachedir: .pytest_cache
rootdir: /Users/Denis/Documents/NOTA/NOTAV2
configfile: pytest.ini
testpaths: tests
plugins: asyncio-0.23.5, anyio-4.9.0, cov-4.1.0
asyncio: mode=auto
collecting ... collected 115 items

tests/test_dates.py::test_get_current_date PASSED                        [  0%]
tests/test_dates.py::test_get_current_datetime PASSED                    [  1%]
tests/test_dates.py::test_parse_date PASSED                              [  2%]
tests/test_dates.py::test_format_date PASSED                             [  3%]
tests/test_dates.py::test_format_datetime PASSED                         [  4%]
tests/test_dates.py::test_add_days PASSED                                [  5%]
tests/test_dates.py::test_add_months PASSED                              [  6%]
tests/test_dates.py::test_get_date_range PASSED                          [  6%]
tests/test_dates.py::test_is_weekend PASSED                              [  7%]
tests/test_dates.py::test_is_holiday PASSED                              [  8%]
tests/test_dates.py::test_get_holiday_name PASSED                        [  9%]
tests/test_dates.py::test_is_workday PASSED                              [ 10%]
tests/test_dates.py::test_get_next_workday PASSED                        [ 11%]
tests/test_dates.py::test_get_previous_workday PASSED                    [ 12%]
tests/test_dates.py::test_convert_timezone FAILED                        [ 13%]
tests/test_dates.py::test_get_workdays_in_range PASSED                   [ 13%]
tests/test_dates.py::test_get_holidays_in_range PASSED                   [ 14%]
tests/test_fuzzy_match.py::test_fuzzy_match_product FAILED               [ 15%]
tests/test_gpt_combined.py::test_split_api_response_with_markers PASSED  [ 16%]
tests/test_gpt_combined.py::test_split_api_response_without_markers PASSED [ 17%]
tests/test_gpt_combined.py::test_split_api_response_only_text PASSED     [ 18%]
tests/test_gpt_combined.py::test_call_combined_api PASSED                [ 19%]
tests/test_gpt_combined.py::test_process_invoice FAILED                  [ 20%]
tests/test_gpt_combined.py::test_ocr_and_parse PASSED                    [ 20%]
tests/test_gpt_combined.py::test_ocr_and_parse_with_error PASSED         [ 21%]
tests/test_integration.py::test_full_invoice_creation_flow ERROR         [ 22%]
tests/test_integration.py::test_product_search_by_alias ERROR            [ 23%]
tests/test_integration.py::test_cascade_delete_flow ERROR                [ 24%]
tests/test_invoice.py::test_invoice_creation ERROR                       [ 25%]
tests/test_invoice.py::test_invoice_supplier_relationship ERROR          [ 26%]
tests/test_invoice.py::test_invoice_items_relationship ERROR             [ 26%]
tests/test_invoice.py::test_invoice_item_product_relationship ERROR      [ 27%]
tests/test_invoice.py::test_invoice_str_representation ERROR             [ 28%]
tests/test_invoice.py::test_invoice_item_str_representation ERROR        [ 29%]
tests/test_invoice.py::test_product_name_lookup_creation ERROR           [ 30%]
tests/test_invoice.py::test_product_name_lookup_product_relationship ERROR [ 31%]
tests/test_invoice.py::test_product_name_lookup_str_representation ERROR [ 32%]
tests/test_invoice.py::test_product_name_lookup_unique_alias ERROR       [ 33%]
tests/test_invoice.py::test_invoice_total_amount ERROR                   [ 33%]
tests/test_invoice.py::test_invoice_validation ERROR                     [ 34%]
tests/test_invoice.py::test_invoice_cascade_delete ERROR                 [ 35%]
tests/test_invoice_item.py::test_invoice_item_creation ERROR             [ 36%]
tests/test_invoice_item.py::test_invoice_item_string_representation ERROR [ 37%]
tests/test_invoice_item.py::test_invoice_item_invoice_relationship ERROR [ 38%]
tests/test_invoice_item.py::test_invoice_item_product_relationship ERROR [ 39%]
tests/test_invoice_item.py::test_invoice_item_validation ERROR           [ 40%]
tests/test_invoice_item.py::test_invoice_item_total_amount ERROR         [ 40%]
tests/test_invoice_item.py::test_invoice_item_unit_validation ERROR      [ 41%]
tests/test_invoice_item.py::test_invoice_item_quantity_precision ERROR   [ 42%]
tests/test_invoice_item.py::test_invoice_item_price_precision ERROR      [ 43%]
tests/test_invoice_item.py::test_invoice_item_total_amount_precision ERROR [ 44%]
tests/test_invoice_item.py::test_invoice_item_update ERROR               [ 45%]
tests/test_invoice_item.py::test_invoice_item_edge_cases ERROR           [ 46%]
tests/test_invoice_item.py::test_invoice_item_invalid_decimal ERROR      [ 46%]
tests/test_invoice_item.py::test_invoice_item_foreign_key_constraints ERROR [ 47%]
tests/test_invoice_item.py::test_invoice_item_name_length ERROR          [ 48%]
tests/test_invoice_item.py::test_invoice_item_comment_length ERROR       [ 49%]
tests/test_issue_editor.py::test_cb_select_issue FAILED                  [ 50%]
tests/test_issue_editor.py::test_cb_action_with_item_name FAILED         [ 51%]
tests/test_issue_editor.py::test_cb_action_with_item_qty FAILED          [ 52%]
tests/test_issue_editor.py::test_cb_select_product FAILED                [ 53%]
tests/test_issue_editor.py::test_process_field_input_quantity FAILED     [ 53%]
tests/test_issue_editor.py::test_clean_name_for_comparison FAILED        [ 54%]
tests/test_issue_editor.py::test_is_semifinished FAILED                  [ 55%]
tests/test_issue_editor.py::test_get_products_by_name ERROR              [ 56%]
tests/test_issue_editor.py::test_save_product_match ERROR                [ 57%]
tests/test_issue_editor.py::test_get_issue_icon FAILED                   [ 58%]
tests/test_issue_editor.py::test_format_issues_list FAILED               [ 59%]
tests/test_issue_editor.py::test_format_issue_edit FAILED                [ 60%]
tests/test_issue_editor.py::test_format_product_select ERROR             [ 60%]
tests/test_issue_editor.py::test_format_field_prompt FAILED              [ 61%]
tests/test_issue_editor.py::test_cb_back FAILED                          [ 62%]
tests/test_issue_editor.py::test_cb_change_page FAILED                   [ 63%]
tests/test_issue_editor.py::test_cb_select_unit FAILED                   [ 64%]
tests/test_issue_editor.py::test_cb_search_product FAILED                [ 65%]
tests/test_issue_editor.py::test_process_field_input_invalid_quantity FAILED [ 66%]
tests/test_issue_editor.py::test_process_field_input_price FAILED        [ 66%]
tests/test_performance.py::test_bulk_insert_performance ERROR            [ 67%]
tests/test_performance.py::test_search_performance ERROR                 [ 68%]
tests/test_performance.py::test_invoice_calculation_performance ERROR    [ 69%]
tests/test_performance.py::test_concurrent_operations_performance ERROR  [ 70%]
tests/test_performance.py::test_index_performance ERROR                  [ 71%]
tests/test_performance.py::test_complex_query_performance ERROR          [ 72%]
tests/test_performance.py::test_memory_usage_performance ERROR           [ 73%]
tests/test_performance.py::test_transaction_performance ERROR            [ 73%]
tests/test_product.py::test_product_creation ERROR                       [ 74%]
tests/test_product.py::test_product_string_representation ERROR          [ 75%]
tests/test_product.py::test_product_name_lookup_relationship ERROR       [ 76%]
tests/test_product.py::test_product_validation ERROR                     [ 77%]
tests/test_product.py::test_product_unique_code ERROR                    [ 78%]
tests/test_product.py::test_product_cascade_delete ERROR                 [ 79%]
tests/test_product_name_lookup.py::test_product_name_lookup_creation ERROR [ 80%]
tests/test_product_name_lookup.py::test_product_name_lookup_string_representation ERROR [ 80%]
tests/test_product_name_lookup.py::test_product_name_lookup_product_relationship ERROR [ 81%]
tests/test_product_name_lookup.py::test_product_name_lookup_validation ERROR [ 82%]
tests/test_product_name_lookup.py::test_product_name_lookup_unique_alias ERROR [ 83%]
tests/test_product_name_lookup.py::test_product_name_lookup_case_insensitive ERROR [ 84%]
tests/test_product_name_lookup.py::test_product_name_lookup_alias_length ERROR [ 85%]
tests/test_product_name_lookup.py::test_product_name_lookup_alias_format ERROR [ 86%]
tests/test_product_name_lookup.py::test_product_name_lookup_comment_length ERROR [ 86%]
tests/test_product_name_lookup.py::test_product_name_lookup_update ERROR [ 87%]
tests/test_product_name_lookup.py::test_product_name_lookup_fuzzy_search ERROR [ 88%]
tests/test_product_name_lookup.py::test_product_name_lookup_cascade_delete ERROR [ 89%]
tests/test_product_name_lookup.py::test_product_name_lookup_edge_cases ERROR [ 90%]
tests/test_product_name_lookup.py::test_product_name_lookup_special_characters ERROR [ 91%]
tests/test_product_name_lookup.py::test_product_name_lookup_foreign_key_constraints ERROR [ 92%]
tests/test_product_name_lookup.py::test_product_name_lookup_duplicate_aliases_different_products ERROR [ 93%]
tests/test_product_name_lookup.py::test_product_name_lookup_case_sensitive_unique ERROR [ 93%]
tests/test_settings.py::test_settings_value PASSED                       [ 94%]
tests/test_supplier.py::test_supplier_creation ERROR                     [ 95%]
tests/test_supplier.py::test_supplier_string_representation ERROR        [ 96%]
tests/test_supplier.py::test_supplier_invoices_relationship ERROR        [ 97%]
tests/test_supplier.py::test_supplier_validation ERROR                   [ 98%]
tests/test_supplier.py::test_supplier_unique_inn ERROR                   [ 99%]
tests/test_supplier.py::test_supplier_cascade_delete ERROR               [100%]

==================================== ERRORS ====================================
______________ ERROR at setup of test_full_invoice_creation_flow _______________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
________________ ERROR at setup of test_product_search_by_alias ________________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
__________________ ERROR at setup of test_cascade_delete_flow __________________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
___________________ ERROR at setup of test_invoice_creation ____________________
file /Users/Denis/Documents/NOTA/NOTAV2/tests/test_invoice.py, line 86
  @pytest.mark.asyncio
  async def test_invoice_creation(session: AsyncSession, sample_invoice: Invoice):
      """Тестирует создание накладной."""
      assert sample_invoice.id is not None
      assert sample_invoice.number == "INV-001"
      assert isinstance(sample_invoice.date, datetime)
      assert isinstance(sample_invoice.comment, str)
      assert sample_invoice.comment == "Test invoice"
      assert sample_invoice.supplier.name == "Test Supplier"
E       fixture 'session' not found
>       available fixtures: _session_event_loop, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, cov, doctest_namespace, event_loop, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, monkeypatch, no_cover, override_get_db, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_invoice, sample_invoice_item, sample_product, sample_product_name_lookup, sample_supplier, test_db, test_engine, test_invoice, test_supplier, tests/test_invoice.py::<event_loop>, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/Denis/Documents/NOTA/NOTAV2/tests/test_invoice.py:86
_____________ ERROR at setup of test_invoice_supplier_relationship _____________
file /Users/Denis/Documents/NOTA/NOTAV2/tests/test_invoice.py, line 96
  @pytest.mark.asyncio
  async def test_invoice_supplier_relationship(
      session: AsyncSession,
      sample_invoice: Invoice,
      sample_supplier: Supplier
  ):
      """Тестирует связь накладной с поставщиком."""
      assert sample_invoice.supplier_id == sample_supplier.id
      assert sample_invoice.supplier.name == "Test Supplier"
      assert sample_invoice.supplier.inn == "1234567890"
      assert sample_invoice.supplier.address == "Test Address"
      assert sample_invoice.supplier.phone == "+1234567890"
      assert sample_invoice.supplier.email == "test@supplier.com"
E       fixture 'session' not found
>       available fixtures: _session_event_loop, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, cov, doctest_namespace, event_loop, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, monkeypatch, no_cover, override_get_db, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_invoice, sample_invoice_item, sample_product, sample_product_name_lookup, sample_supplier, test_db, test_engine, test_invoice, test_supplier, tests/test_invoice.py::<event_loop>, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/Denis/Documents/NOTA/NOTAV2/tests/test_invoice.py:96
______________ ERROR at setup of test_invoice_items_relationship _______________
file /Users/Denis/Documents/NOTA/NOTAV2/tests/test_invoice.py, line 110
  @pytest.mark.asyncio
  async def test_invoice_items_relationship(
      session: AsyncSession,
      sample_invoice: Invoice,
      sample_invoice_item: InvoiceItem
  ):
      """Тестирует связь накладной с элементами."""
      assert len(sample_invoice.items) == 1
      item = sample_invoice.items[0]
      assert isinstance(item.name, str)
      assert isinstance(item.quantity, float)
      assert isinstance(item.unit, str)
      assert isinstance(item.price, float)
      assert item.name == "Test Item"
      assert item.quantity == 10.0
      assert item.unit == "pcs"
      assert item.price == 100.0
E       fixture 'session' not found
>       available fixtures: _session_event_loop, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, cov, doctest_namespace, event_loop, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, monkeypatch, no_cover, override_get_db, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_invoice, sample_invoice_item, sample_product, sample_product_name_lookup, sample_supplier, test_db, test_engine, test_invoice, test_supplier, tests/test_invoice.py::<event_loop>, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/Denis/Documents/NOTA/NOTAV2/tests/test_invoice.py:110
___________ ERROR at setup of test_invoice_item_product_relationship ___________
file /Users/Denis/Documents/NOTA/NOTAV2/tests/test_invoice.py, line 128
  @pytest.mark.asyncio
  async def test_invoice_item_product_relationship(
      session: AsyncSession,
      sample_invoice_item: InvoiceItem,
      sample_product: Product
  ):
      """Тестирует связь элемента накладной с товаром."""
      assert sample_invoice_item.product_id == sample_product.id
      assert sample_invoice_item.product.name == "Test Product"
      assert sample_invoice_item.product.unit == "pcs"
      assert float(sample_invoice_item.product.price) == 100.0
E       fixture 'session' not found
>       available fixtures: _session_event_loop, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, cov, doctest_namespace, event_loop, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, monkeypatch, no_cover, override_get_db, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_invoice, sample_invoice_item, sample_product, sample_product_name_lookup, sample_supplier, test_db, test_engine, test_invoice, test_supplier, tests/test_invoice.py::<event_loop>, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/Denis/Documents/NOTA/NOTAV2/tests/test_invoice.py:128
______________ ERROR at setup of test_invoice_str_representation _______________
file /Users/Denis/Documents/NOTA/NOTAV2/tests/test_invoice.py, line 140
  @pytest.mark.asyncio
  async def test_invoice_str_representation(sample_invoice: Invoice):
      """Тестирует строковое представление накладной."""
      expected = f"Накладная INV-001 от {sample_invoice.date.strftime('%d.%m.%Y')}"
      assert str(sample_invoice) == expected
      assert isinstance(sample_invoice.date, datetime)
      assert sample_invoice.date.strftime('%d.%m.%Y') in str(sample_invoice)
file /Users/Denis/Documents/NOTA/NOTAV2/tests/test_invoice.py, line 39
  @pytest.fixture
  async def sample_invoice(session: AsyncSession, sample_supplier: Supplier) -> Invoice:
      """Создает тестовую накладную."""
      invoice = Invoice(
          number="INV-001",
          date=datetime.now(),
          supplier_id=sample_supplier.id,
          comment="Test invoice"
      )
      session.add(invoice)
      await session.commit()
      return invoice
E       fixture 'session' not found
>       available fixtures: _session_event_loop, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, cov, doctest_namespace, event_loop, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, monkeypatch, no_cover, override_get_db, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_invoice, sample_invoice_item, sample_product, sample_product_name_lookup, sample_supplier, test_db, test_engine, test_invoice, test_supplier, tests/test_invoice.py::<event_loop>, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/Denis/Documents/NOTA/NOTAV2/tests/test_invoice.py:39
____________ ERROR at setup of test_invoice_item_str_representation ____________
file /Users/Denis/Documents/NOTA/NOTAV2/tests/test_invoice.py, line 148
  @pytest.mark.asyncio
  async def test_invoice_item_str_representation(sample_invoice_item: InvoiceItem):
      """Тестирует строковое представление элемента накладной."""
      expected = f"{sample_invoice_item.name} - {sample_invoice_item.quantity} {sample_invoice_item.unit}"
      assert str(sample_invoice_item) == expected
      assert isinstance(sample_invoice_item.name, str)
      assert isinstance(sample_invoice_item.quantity, float)
      assert isinstance(sample_invoice_item.unit, str)
file /Users/Denis/Documents/NOTA/NOTAV2/tests/test_invoice.py, line 52
  @pytest.fixture
  async def sample_invoice_item(
      session: AsyncSession,
      sample_invoice: Invoice,
      sample_product: Product
  ) -> InvoiceItem:
      """Создает тестовый элемент накладной."""
      item = InvoiceItem(
          invoice_id=sample_invoice.id,
          product_id=sample_product.id,
          name="Test Item",
          quantity=10.0,
          unit="pcs",
          price=100.0
      )
      session.add(item)
      await session.commit()
      return item
E       fixture 'session' not found
>       available fixtures: _session_event_loop, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, cov, doctest_namespace, event_loop, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, monkeypatch, no_cover, override_get_db, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_invoice, sample_invoice_item, sample_product, sample_product_name_lookup, sample_supplier, test_db, test_engine, test_invoice, test_supplier, tests/test_invoice.py::<event_loop>, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/Denis/Documents/NOTA/NOTAV2/tests/test_invoice.py:52
_____________ ERROR at setup of test_product_name_lookup_creation ______________
file /Users/Denis/Documents/NOTA/NOTAV2/tests/test_invoice.py, line 157
  @pytest.mark.asyncio
  async def test_product_name_lookup_creation(
      session: AsyncSession,
      sample_product_name_lookup: ProductNameLookup
  ):
      """Тестирует создание записи сопоставления названий товаров."""
      assert sample_product_name_lookup.id is not None
      assert isinstance(sample_product_name_lookup.alias, str)
      assert isinstance(sample_product_name_lookup.comment, str)
      assert sample_product_name_lookup.alias == "Test Product Alias"
      assert sample_product_name_lookup.comment == "Test lookup entry"
E       fixture 'session' not found
>       available fixtures: _session_event_loop, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, cov, doctest_namespace, event_loop, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, monkeypatch, no_cover, override_get_db, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_invoice, sample_invoice_item, sample_product, sample_product_name_lookup, sample_supplier, test_db, test_engine, test_invoice, test_supplier, tests/test_invoice.py::<event_loop>, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/Denis/Documents/NOTA/NOTAV2/tests/test_invoice.py:157
_______ ERROR at setup of test_product_name_lookup_product_relationship ________
file /Users/Denis/Documents/NOTA/NOTAV2/tests/test_invoice.py, line 169
  @pytest.mark.asyncio
  async def test_product_name_lookup_product_relationship(
      session: AsyncSession,
      sample_product_name_lookup: ProductNameLookup,
      sample_product: Product
  ):
      """Тестирует связь записи сопоставления с товаром."""
      assert sample_product_name_lookup.product_id == sample_product.id
      assert isinstance(sample_product_name_lookup.product.name, str)
      assert isinstance(sample_product_name_lookup.product.unit, str)
      assert isinstance(sample_product_name_lookup.product.price, float)
      assert sample_product_name_lookup.product.name == "Test Product"
      assert sample_product_name_lookup.product.unit == "pcs"
      assert sample_product_name_lookup.product.price == 100.0
E       fixture 'session' not found
>       available fixtures: _session_event_loop, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, cov, doctest_namespace, event_loop, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, monkeypatch, no_cover, override_get_db, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_invoice, sample_invoice_item, sample_product, sample_product_name_lookup, sample_supplier, test_db, test_engine, test_invoice, test_supplier, tests/test_invoice.py::<event_loop>, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/Denis/Documents/NOTA/NOTAV2/tests/test_invoice.py:169
________ ERROR at setup of test_product_name_lookup_str_representation _________
file /Users/Denis/Documents/NOTA/NOTAV2/tests/test_invoice.py, line 184
  @pytest.mark.asyncio
  async def test_product_name_lookup_str_representation(
      sample_product_name_lookup: ProductNameLookup
  ):
      """Тестирует строковое представление записи сопоставления."""
      expected = f"{sample_product_name_lookup.alias} -> {sample_product_name_lookup.product.name}"
      assert str(sample_product_name_lookup) == expected
      assert isinstance(sample_product_name_lookup.alias, str)
      assert isinstance(sample_product_name_lookup.product.name, str)
      assert " -> " in str(sample_product_name_lookup)
file /Users/Denis/Documents/NOTA/NOTAV2/tests/test_invoice.py, line 71
  @pytest.fixture
  async def sample_product_name_lookup(
      session: AsyncSession,
      sample_product: Product
  ) -> ProductNameLookup:
      """Создает тестовую запись сопоставления названий товаров."""
      lookup = ProductNameLookup(
          alias="Test Product Alias",
          product_id=sample_product.id,
          comment="Test lookup entry"
      )
      session.add(lookup)
      await session.commit()
      return lookup
E       fixture 'session' not found
>       available fixtures: _session_event_loop, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, cov, doctest_namespace, event_loop, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, monkeypatch, no_cover, override_get_db, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_invoice, sample_invoice_item, sample_product, sample_product_name_lookup, sample_supplier, test_db, test_engine, test_invoice, test_supplier, tests/test_invoice.py::<event_loop>, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/Denis/Documents/NOTA/NOTAV2/tests/test_invoice.py:71
___________ ERROR at setup of test_product_name_lookup_unique_alias ____________
file /Users/Denis/Documents/NOTA/NOTAV2/tests/test_invoice.py, line 195
  @pytest.mark.asyncio
  async def test_product_name_lookup_unique_alias(
      session: AsyncSession,
      sample_product: Product
  ):
      """Тестирует уникальность алиаса в записях сопоставления."""
      # Создаем первую запись
      lookup1 = ProductNameLookup(
          alias="Unique Alias",
          product_id=sample_product.id
      )
      session.add(lookup1)
      await session.commit()

      # Пытаемся создать вторую запись с тем же алиасом
      lookup2 = ProductNameLookup(
          alias="Unique Alias",
          product_id=sample_product.id
      )
      session.add(lookup2)

      # Должно вызвать исключение из-за нарушения уникальности
      with pytest.raises(IntegrityError):
          await session.commit()
E       fixture 'session' not found
>       available fixtures: _session_event_loop, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, cov, doctest_namespace, event_loop, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, monkeypatch, no_cover, override_get_db, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_invoice, sample_invoice_item, sample_product, sample_product_name_lookup, sample_supplier, test_db, test_engine, test_invoice, test_supplier, tests/test_invoice.py::<event_loop>, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/Denis/Documents/NOTA/NOTAV2/tests/test_invoice.py:195
_________________ ERROR at setup of test_invoice_total_amount __________________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
__________________ ERROR at setup of test_invoice_validation ___________________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
________________ ERROR at setup of test_invoice_cascade_delete _________________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
_________________ ERROR at setup of test_invoice_item_creation _________________
file /Users/Denis/Documents/NOTA/NOTAV2/tests/test_invoice_item.py, line 8
  @pytest.mark.asyncio
  async def test_invoice_item_creation(test_invoice_item):
      """Тест создания позиции счета."""
      assert test_invoice_item.name == "Тестовый товар"
      assert test_invoice_item.quantity == Decimal("10")
      assert test_invoice_item.unit == "шт"
      assert test_invoice_item.price == Decimal("100.50")
      assert test_invoice_item.comment == "Тестовый комментарий"
E       fixture 'test_invoice_item' not found
>       available fixtures: _session_event_loop, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, cov, doctest_namespace, event_loop, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, monkeypatch, no_cover, override_get_db, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, test_db, test_engine, test_invoice, test_supplier, tests/test_invoice_item.py::<event_loop>, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/Denis/Documents/NOTA/NOTAV2/tests/test_invoice_item.py:8
__________ ERROR at setup of test_invoice_item_string_representation ___________
file /Users/Denis/Documents/NOTA/NOTAV2/tests/test_invoice_item.py, line 17
  @pytest.mark.asyncio
  async def test_invoice_item_string_representation(test_invoice_item):
      """Тест строкового представления позиции счета."""
      expected = f"{test_invoice_item.name} - {test_invoice_item.quantity} {test_invoice_item.unit}"
      assert str(test_invoice_item) == expected
E       fixture 'test_invoice_item' not found
>       available fixtures: _session_event_loop, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, cov, doctest_namespace, event_loop, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, monkeypatch, no_cover, override_get_db, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, test_db, test_engine, test_invoice, test_supplier, tests/test_invoice_item.py::<event_loop>, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/Denis/Documents/NOTA/NOTAV2/tests/test_invoice_item.py:17
___________ ERROR at setup of test_invoice_item_invoice_relationship ___________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
___________ ERROR at setup of test_invoice_item_product_relationship ___________
file /Users/Denis/Documents/NOTA/NOTAV2/tests/test_invoice_item.py, line 30
  @pytest.mark.asyncio
  async def test_invoice_item_product_relationship(test_invoice_item, test_product):
      """Тест связи позиции счета с товаром."""
      assert test_invoice_item.product_id == test_product.id
      assert test_invoice_item.product.name == "Тестовый товар"
      assert test_invoice_item.product.code == "TEST001"
      assert test_invoice_item.product.unit == "шт"
E       fixture 'test_invoice_item' not found
>       available fixtures: _session_event_loop, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, cov, doctest_namespace, event_loop, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, monkeypatch, no_cover, override_get_db, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, test_db, test_engine, test_invoice, test_supplier, tests/test_invoice_item.py::<event_loop>, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/Denis/Documents/NOTA/NOTAV2/tests/test_invoice_item.py:30
________________ ERROR at setup of test_invoice_item_validation ________________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
_______________ ERROR at setup of test_invoice_item_total_amount _______________
file /Users/Denis/Documents/NOTA/NOTAV2/tests/test_invoice_item.py, line 80
  @pytest.mark.asyncio
  async def test_invoice_item_total_amount(test_invoice_item):
      """Тест расчета общей суммы позиции."""
      total = test_invoice_item.quantity * test_invoice_item.price
      expected_total = Decimal("10") * Decimal("100.50")
      assert total == expected_total
E       fixture 'test_invoice_item' not found
>       available fixtures: _session_event_loop, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, cov, doctest_namespace, event_loop, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, monkeypatch, no_cover, override_get_db, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, test_db, test_engine, test_invoice, test_supplier, tests/test_invoice_item.py::<event_loop>, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/Denis/Documents/NOTA/NOTAV2/tests/test_invoice_item.py:80
_____________ ERROR at setup of test_invoice_item_unit_validation ______________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
____________ ERROR at setup of test_invoice_item_quantity_precision ____________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
_____________ ERROR at setup of test_invoice_item_price_precision ______________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
__________ ERROR at setup of test_invoice_item_total_amount_precision __________
file /Users/Denis/Documents/NOTA/NOTAV2/tests/test_invoice_item.py, line 148
  @pytest.mark.asyncio
  async def test_invoice_item_total_amount_precision(test_invoice_item):
      """Тест точности расчета общей суммы."""
      # Проверяем, что общая сумма округляется до 2 знаков после запятой
      total = test_invoice_item.quantity * test_invoice_item.price
      assert total.quantize(Decimal("0.01")) == Decimal("1005.00")
E       fixture 'test_invoice_item' not found
>       available fixtures: _session_event_loop, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, cov, doctest_namespace, event_loop, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, monkeypatch, no_cover, override_get_db, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, test_db, test_engine, test_invoice, test_supplier, tests/test_invoice_item.py::<event_loop>, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/Denis/Documents/NOTA/NOTAV2/tests/test_invoice_item.py:148
__________________ ERROR at setup of test_invoice_item_update __________________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
________________ ERROR at setup of test_invoice_item_edge_cases ________________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
_____________ ERROR at setup of test_invoice_item_invalid_decimal ______________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
_________ ERROR at setup of test_invoice_item_foreign_key_constraints __________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
_______________ ERROR at setup of test_invoice_item_name_length ________________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
______________ ERROR at setup of test_invoice_item_comment_length ______________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
_________________ ERROR at setup of test_get_products_by_name __________________
file /Users/Denis/Documents/NOTA/NOTAV2/tests/test_issue_editor.py, line 377
  @pytest.mark.asyncio
  async def test_get_products_by_name(session: AsyncSession):
      """Тестирует поиск товаров по названию."""
      # Создаем тестовые товары
      products = [
          {"name": "Test Product 1", "unit": "pcs"},
          {"name": "Test Product 2", "unit": "kg"},
          {"name": "Another Product", "unit": "g"}
      ]

      for product_data in products:
          product = Product(**product_data)
          session.add(product)
      await session.commit()

      # Тестируем поиск
      results = await get_products_by_name(session, "Test Product", limit=2)
      assert len(results) == 2
      assert all("Test Product" in p["name"] for p in results)

      # Тестируем поиск с порогом схожести
      results = await get_products_by_name(session, "Test", threshold=0.9)
      assert len(results) == 2
E       fixture 'session' not found
>       available fixtures: _session_event_loop, anyio_backend, anyio_backend_name, anyio_backend_options, cache, callback_query, capfd, capfdbinary, caplog, capsys, capsysbinary, cov, doctest_namespace, event_loop, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, message, monkeypatch, no_cover, override_get_db, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_issue, sample_issues, state, state_data, test_db, test_engine, test_invoice, test_supplier, tests/test_issue_editor.py::<event_loop>, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/Denis/Documents/NOTA/NOTAV2/tests/test_issue_editor.py:377
__________________ ERROR at setup of test_save_product_match ___________________
file /Users/Denis/Documents/NOTA/NOTAV2/tests/test_issue_editor.py, line 402
  @pytest.mark.asyncio
  async def test_save_product_match(session: AsyncSession):
      """Тестирует сохранение сопоставления товара."""
      # Создаем тестовый товар
      product = Product(name="Test Product", unit="pcs")
      session.add(product)
      await session.commit()

      # Тестируем сохранение сопоставления
      success = await save_product_match(session, "Test Product Alias", product.id)
      assert success is True

      # Проверяем, что сопоставление создано
      lookup = await session.execute(
          select(ProductNameLookup).where(ProductNameLookup.alias == "Test Product Alias")
      )
      assert lookup.scalar_one_or_none() is not None
E       fixture 'session' not found
>       available fixtures: _session_event_loop, anyio_backend, anyio_backend_name, anyio_backend_options, cache, callback_query, capfd, capfdbinary, caplog, capsys, capsysbinary, cov, doctest_namespace, event_loop, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, message, monkeypatch, no_cover, override_get_db, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_issue, sample_issues, state, state_data, test_db, test_engine, test_invoice, test_supplier, tests/test_issue_editor.py::<event_loop>, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/Denis/Documents/NOTA/NOTAV2/tests/test_issue_editor.py:402
_________________ ERROR at setup of test_format_product_select _________________
file /Users/Denis/Documents/NOTA/NOTAV2/tests/test_issue_editor.py, line 459
  @pytest.mark.asyncio
  async def test_format_product_select(session: AsyncSession):
      """Тестирует форматирование выбора товара."""
      # Создаем тестовые товары
      products = [
          {"name": "Test Product 1", "unit": "pcs"},
          {"name": "Test Product 2", "unit": "kg"}
      ]

      for product_data in products:
          product = Product(**product_data)
          session.add(product)
      await session.commit()

      message, keyboard = await format_product_select(
          [{"id": p.id, "name": p.name, "unit": p.unit} for p in products],
          "Test",
          page=0
      )

      assert isinstance(message, str)
      assert isinstance(keyboard, InlineKeyboardMarkup)
      assert "Test Product 1" in message
      assert "Test Product 2" in message
E       fixture 'session' not found
>       available fixtures: _session_event_loop, anyio_backend, anyio_backend_name, anyio_backend_options, cache, callback_query, capfd, capfdbinary, caplog, capsys, capsysbinary, cov, doctest_namespace, event_loop, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, message, monkeypatch, no_cover, override_get_db, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_issue, sample_issues, state, state_data, test_db, test_engine, test_invoice, test_supplier, tests/test_issue_editor.py::<event_loop>, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/Denis/Documents/NOTA/NOTAV2/tests/test_issue_editor.py:459
________________ ERROR at setup of test_bulk_insert_performance ________________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
__________________ ERROR at setup of test_search_performance ___________________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
____________ ERROR at setup of test_invoice_calculation_performance ____________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
___________ ERROR at setup of test_concurrent_operations_performance ___________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
___________________ ERROR at setup of test_index_performance ___________________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
_______________ ERROR at setup of test_complex_query_performance _______________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
_______________ ERROR at setup of test_memory_usage_performance ________________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
________________ ERROR at setup of test_transaction_performance ________________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
___________________ ERROR at setup of test_product_creation ____________________
file /Users/Denis/Documents/NOTA/NOTAV2/tests/test_product.py, line 8
  @pytest.mark.asyncio
  async def test_product_creation(test_product):
      """Тест создания товара."""
      assert test_product.name == "Тестовый товар"
      assert test_product.code == "TEST001"
      assert test_product.unit == "шт"
      assert test_product.price == Decimal("100.50")
      assert test_product.comment == "Тестовый комментарий"
E       fixture 'test_product' not found
>       available fixtures: _session_event_loop, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, cov, doctest_namespace, event_loop, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, monkeypatch, no_cover, override_get_db, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, test_db, test_engine, test_invoice, test_supplier, tests/test_product.py::<event_loop>, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/Denis/Documents/NOTA/NOTAV2/tests/test_product.py:8
_____________ ERROR at setup of test_product_string_representation _____________
file /Users/Denis/Documents/NOTA/NOTAV2/tests/test_product.py, line 17
  @pytest.mark.asyncio
  async def test_product_string_representation(test_product):
      """Тест строкового представления товара."""
      expected = f"{test_product.name} ({test_product.code})"
      assert str(test_product) == expected
E       fixture 'test_product' not found
>       available fixtures: _session_event_loop, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, cov, doctest_namespace, event_loop, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, monkeypatch, no_cover, override_get_db, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, test_db, test_engine, test_invoice, test_supplier, tests/test_product.py::<event_loop>, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/Denis/Documents/NOTA/NOTAV2/tests/test_product.py:17
___________ ERROR at setup of test_product_name_lookup_relationship ____________
file /Users/Denis/Documents/NOTA/NOTAV2/tests/test_product.py, line 23
  @pytest.mark.asyncio
  async def test_product_name_lookup_relationship(test_product, test_product_name_lookup):
      """Тест связи товара с записями поиска по названию."""
      assert len(test_product.name_lookups) == 1
      lookup = test_product.name_lookups[0]
      assert lookup.alias == "тестовый товар"
      assert lookup.product_id == test_product.id
E       fixture 'test_product' not found
>       available fixtures: _session_event_loop, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, cov, doctest_namespace, event_loop, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, monkeypatch, no_cover, override_get_db, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, test_db, test_engine, test_invoice, test_supplier, tests/test_product.py::<event_loop>, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/Denis/Documents/NOTA/NOTAV2/tests/test_product.py:23
__________________ ERROR at setup of test_product_validation ___________________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
__________________ ERROR at setup of test_product_unique_code __________________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
________________ ERROR at setup of test_product_cascade_delete _________________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
_____________ ERROR at setup of test_product_name_lookup_creation ______________
file /Users/Denis/Documents/NOTA/NOTAV2/tests/test_product_name_lookup.py, line 8
  @pytest.mark.asyncio
  async def test_product_name_lookup_creation(test_product_name_lookup):
      """Тест создания записи поиска по названию товара."""
      assert test_product_name_lookup.alias == "тестовый товар"
      assert test_product_name_lookup.comment == "Тестовый комментарий"
E       fixture 'test_product_name_lookup' not found
>       available fixtures: _session_event_loop, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, cov, doctest_namespace, event_loop, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, monkeypatch, no_cover, override_get_db, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, test_db, test_engine, test_invoice, test_supplier, tests/test_product_name_lookup.py::<event_loop>, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/Denis/Documents/NOTA/NOTAV2/tests/test_product_name_lookup.py:8
_______ ERROR at setup of test_product_name_lookup_string_representation _______
file /Users/Denis/Documents/NOTA/NOTAV2/tests/test_product_name_lookup.py, line 14
  @pytest.mark.asyncio
  async def test_product_name_lookup_string_representation(test_product_name_lookup):
      """Тест строкового представления записи поиска."""
      expected = f"{test_product_name_lookup.alias} -> {test_product_name_lookup.product.name}"
      assert str(test_product_name_lookup) == expected
E       fixture 'test_product_name_lookup' not found
>       available fixtures: _session_event_loop, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, cov, doctest_namespace, event_loop, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, monkeypatch, no_cover, override_get_db, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, test_db, test_engine, test_invoice, test_supplier, tests/test_product_name_lookup.py::<event_loop>, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/Denis/Documents/NOTA/NOTAV2/tests/test_product_name_lookup.py:14
_______ ERROR at setup of test_product_name_lookup_product_relationship ________
file /Users/Denis/Documents/NOTA/NOTAV2/tests/test_product_name_lookup.py, line 20
  @pytest.mark.asyncio
  async def test_product_name_lookup_product_relationship(test_product_name_lookup, test_product):
      """Тест связи записи поиска с товаром."""
      assert test_product_name_lookup.product_id == test_product.id
      assert test_product_name_lookup.product.name == "Тестовый товар"
      assert test_product_name_lookup.product.code == "TEST001"
      assert test_product_name_lookup.product.unit == "шт"
E       fixture 'test_product_name_lookup' not found
>       available fixtures: _session_event_loop, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, cov, doctest_namespace, event_loop, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, monkeypatch, no_cover, override_get_db, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, test_db, test_engine, test_invoice, test_supplier, tests/test_product_name_lookup.py::<event_loop>, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/Denis/Documents/NOTA/NOTAV2/tests/test_product_name_lookup.py:20
____________ ERROR at setup of test_product_name_lookup_validation _____________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
___________ ERROR at setup of test_product_name_lookup_unique_alias ____________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
_________ ERROR at setup of test_product_name_lookup_case_insensitive __________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
___________ ERROR at setup of test_product_name_lookup_alias_length ____________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
___________ ERROR at setup of test_product_name_lookup_alias_format ____________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
__________ ERROR at setup of test_product_name_lookup_comment_length ___________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
______________ ERROR at setup of test_product_name_lookup_update _______________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
___________ ERROR at setup of test_product_name_lookup_fuzzy_search ____________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
__________ ERROR at setup of test_product_name_lookup_cascade_delete ___________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
____________ ERROR at setup of test_product_name_lookup_edge_cases _____________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
________ ERROR at setup of test_product_name_lookup_special_characters _________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
______ ERROR at setup of test_product_name_lookup_foreign_key_constraints ______

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
_ ERROR at setup of test_product_name_lookup_duplicate_aliases_different_products _

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
_______ ERROR at setup of test_product_name_lookup_case_sensitive_unique _______

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
___________________ ERROR at setup of test_supplier_creation ___________________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
____________ ERROR at setup of test_supplier_string_representation _____________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
____________ ERROR at setup of test_supplier_invoices_relationship _____________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
__________________ ERROR at setup of test_supplier_validation __________________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
__________________ ERROR at setup of test_supplier_unique_inn __________________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
________________ ERROR at setup of test_supplier_cascade_delete ________________

request = <SubRequest 'test_engine' for <Coroutine test_full_invoice_creation_flow>>
kwargs = {}, func = <function test_engine at 0x105d92280>
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x108040d30>
finalizer = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.finalizer at 0x108040c10>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: SubRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(
            fixture, request.instance, fixturedef.unittest
        )
        event_loop = kwargs.pop(event_loop_fixture_id)
        gen_obj = func(
            **_add_kwargs(func, kwargs, event_loop_fixture_id, event_loop, request)
        )
    
        async def setup():
            res = await gen_obj.__anext__()
            return res
    
        def finalizer() -> None:
            """Yield again, to finalize."""
    
            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)
    
            event_loop.run_until_complete(async_finalizer())
    
>       result = event_loop.run_until_complete(setup())

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:329: in setup
    res = await gen_obj.__anext__()
tests/conftest.py:29: in test_engine
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:120: in create_async_engine
    sync_engine = _create_engine(url, **kw)
.venv/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:281: in warned
    return fn(*args, **kwargs)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:599: in create_engine
    dbapi = dbapi_meth(**dbapi_args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite'>

    @classmethod
    def import_dbapi(cls):
        return AsyncAdapt_aiosqlite_dbapi(
>           __import__("aiosqlite"), __import__("sqlite3")
        )
E       ModuleNotFoundError: No module named 'aiosqlite'

.venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:374: ModuleNotFoundError
=================================== FAILURES ===================================
____________________________ test_convert_timezone _____________________________

    def test_convert_timezone():
        """Тест конвертации часовых поясов."""
        # Создаем время в UTC
        utc_time = datetime(2024, 3, 20, 12, 0)
    
        # Конвертируем в Джакарту (UTC+7)
        jakarta_time = convert_timezone(utc_time, "UTC", "Asia/Jakarta")
        assert jakarta_time.hour == 19
    
        # Конвертируем обратно в UTC
>       back_to_utc = convert_timezone(jakarta_time, "Asia/Jakarta", "UTC")

tests/test_dates.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/utils/dates.py:107: in convert_timezone
    localized_dt = from_zone.localize(dt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <DstTzInfo 'Asia/Jakarta' LMT+7:07:00 STD>
dt = datetime.datetime(2024, 3, 20, 19, 0, tzinfo=<DstTzInfo 'Asia/Jakarta' WIB+7:00:00 STD>)
is_dst = False

    def localize(self, dt, is_dst=False):
        '''Convert naive time to local time.
    
        This method should be used to construct localtimes, rather
        than passing a tzinfo argument to a datetime constructor.
    
        is_dst is used to determine the correct timezone in the ambigous
        period at the end of daylight saving time.
    
        >>> from pytz import timezone
        >>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'
        >>> amdam = timezone('Europe/Amsterdam')
        >>> dt  = datetime(2004, 10, 31, 2, 0, 0)
        >>> loc_dt1 = amdam.localize(dt, is_dst=True)
        >>> loc_dt2 = amdam.localize(dt, is_dst=False)
        >>> loc_dt1.strftime(fmt)
        '2004-10-31 02:00:00 CEST (+0200)'
        >>> loc_dt2.strftime(fmt)
        '2004-10-31 02:00:00 CET (+0100)'
        >>> str(loc_dt2 - loc_dt1)
        '1:00:00'
    
        Use is_dst=None to raise an AmbiguousTimeError for ambiguous
        times at the end of daylight saving time
    
        >>> try:
        ...     loc_dt1 = amdam.localize(dt, is_dst=None)
        ... except AmbiguousTimeError:
        ...     print('Ambiguous')
        Ambiguous
    
        is_dst defaults to False
    
        >>> amdam.localize(dt) == amdam.localize(dt, False)
        True
    
        is_dst is also used to determine the correct timezone in the
        wallclock times jumped over at the start of daylight saving time.
    
        >>> pacific = timezone('US/Pacific')
        >>> dt = datetime(2008, 3, 9, 2, 0, 0)
        >>> ploc_dt1 = pacific.localize(dt, is_dst=True)
        >>> ploc_dt2 = pacific.localize(dt, is_dst=False)
        >>> ploc_dt1.strftime(fmt)
        '2008-03-09 02:00:00 PDT (-0700)'
        >>> ploc_dt2.strftime(fmt)
        '2008-03-09 02:00:00 PST (-0800)'
        >>> str(ploc_dt2 - ploc_dt1)
        '1:00:00'
    
        Use is_dst=None to raise a NonExistentTimeError for these skipped
        times.
    
        >>> try:
        ...     loc_dt1 = pacific.localize(dt, is_dst=None)
        ... except NonExistentTimeError:
        ...     print('Non-existent')
        Non-existent
        '''
        if dt.tzinfo is not None:
>           raise ValueError('Not naive datetime (tzinfo is already set)')
E           ValueError: Not naive datetime (tzinfo is already set)

.venv/lib/python3.9/site-packages/pytz/tzinfo.py:321: ValueError
___________________________ test_fuzzy_match_product ___________________________

    @pytest.mark.asyncio
    async def test_fuzzy_match_product():
>       async with engine.begin() as conn:

tests/test_fuzzy_match.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/contextlib.py:175: in __aenter__
    return await self.gen.__anext__()
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:1063: in begin
    async with conn:
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/base.py:121: in __aenter__
    return await self.start(is_ctxmanager=True)
.venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/engine.py:273: in start
    await greenlet_spawn(self.sync_engine.connect)
.venv/lib/python3.9/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
.venv/lib/python3.9/site-packages/sqlalchemy/engine/base.py:3280: in connect
    return self._connection_cls(self)
.venv/lib/python3.9/site-packages/sqlalchemy/engine/base.py:146: in __init__
    self._dbapi_connection = engine.raw_connection()
.venv/lib/python3.9/site-packages/sqlalchemy/engine/base.py:3304: in raw_connection
    return self.pool.connect()
.venv/lib/python3.9/site-packages/sqlalchemy/pool/base.py:449: in connect
    return _ConnectionFairy._checkout(self)
.venv/lib/python3.9/site-packages/sqlalchemy/pool/base.py:1263: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
.venv/lib/python3.9/site-packages/sqlalchemy/pool/base.py:712: in checkout
    rec = pool._do_get()
.venv/lib/python3.9/site-packages/sqlalchemy/pool/impl.py:180: in _do_get
    self._dec_overflow()
.venv/lib/python3.9/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv/lib/python3.9/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    return self._create_connection()
.venv/lib/python3.9/site-packages/sqlalchemy/pool/base.py:390: in _create_connection
    return _ConnectionRecord(self)
.venv/lib/python3.9/site-packages/sqlalchemy/pool/base.py:674: in __init__
    self.__connect()
.venv/lib/python3.9/site-packages/sqlalchemy/pool/base.py:901: in __connect
    pool.logger.debug("Error on connect(): %s", e)
.venv/lib/python3.9/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv/lib/python3.9/site-packages/sqlalchemy/pool/base.py:896: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
.venv/lib/python3.9/site-packages/sqlalchemy/engine/create.py:643: in connect
    return dialect.connect(*cargs, **cparams)
.venv/lib/python3.9/site-packages/sqlalchemy/engine/default.py:617: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
.venv/lib/python3.9/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:937: in connect
    await_only(creator_fn(*arg, **kw)),
.venv/lib/python3.9/site-packages/sqlalchemy/util/_concurrency_py3k.py:131: in await_only
    return current.driver.switch(awaitable)  # type: ignore[no-any-return]
.venv/lib/python3.9/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
.venv/lib/python3.9/site-packages/asyncpg/connection.py:2329: in connect
    return await connect_utils._connect(
.venv/lib/python3.9/site-packages/asyncpg/connect_utils.py:1017: in _connect
    raise last_error or exceptions.TargetServerAttributeNotMatched(
.venv/lib/python3.9/site-packages/asyncpg/connect_utils.py:991: in _connect
    conn = await _connect_addr(
.venv/lib/python3.9/site-packages/asyncpg/connect_utils.py:828: in _connect_addr
    return await __connect_addr(params, True, *args)
.venv/lib/python3.9/site-packages/asyncpg/connect_utils.py:873: in __connect_addr
    tr, pr = await connector
.venv/lib/python3.9/site-packages/asyncpg/connect_utils.py:744: in _create_ssl_connection
    tr, pr = await loop.create_connection(
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:1056: in create_connection
    raise exceptions[0]
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:1041: in create_connection
    sock = await self._connect_sock(
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:955: in _connect_sock
    await self.sock_connect(sock, address)
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/selector_events.py:502: in sock_connect
    return await fut
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_UnixSelectorEventLoop running=False closed=False debug=False>
fut = <Future finished exception=ConnectionRefusedError(61, "Connect call failed ('127.0.0.1', 5432)")>
sock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6>
address = ('127.0.0.1', 5432)

    def _sock_connect_cb(self, fut, sock, address):
        if fut.done():
            return
    
        try:
            err = sock.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)
            if err != 0:
                # Jump to any except clause below.
>               raise OSError(err, f'Connect call failed {address}')
E               ConnectionRefusedError: [Errno 61] Connect call failed ('127.0.0.1', 5432)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/selector_events.py:537: ConnectionRefusedError
_____________________________ test_process_invoice _____________________________

self = <Coroutine test_process_invoice>

    def runtest(self) -> None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
>       super().runtest()

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:440: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:907: in inner
    _loop.run_until_complete(task)
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/unittest/mock.py:1351: in patched
    with self.decoration_helper(patched,
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/contextlib.py:117: in __enter__
    return next(self.gen)
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/unittest/mock.py:1316: in decoration_helper
    arg = exit_stack.enter_context(patching)
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/contextlib.py:429: in enter_context
    result = _cm_type.__enter__(cm)
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/unittest/mock.py:1405: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x107d33610>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.routers.gpt_combined' from '/Users/Denis/Documents/NOTA/NOTAV2/app/routers/gpt_combined.py'> does not have the attribute '_tg_download'

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/unittest/mock.py:1378: AttributeError
_____________________________ test_cb_select_issue _____________________________

callback_query = <AsyncMock spec='CallbackQuery' id='4440396032'>
state = <aiogram.fsm.context.FSMContext object at 0x1083ef5b0>

    @pytest.mark.asyncio
    async def test_cb_select_issue(callback_query, state):
        """Тест выбора проблемной позиции из списка."""
        callback_query.data = "issue_0"  # Выбираем первую проблему
    
>       await cb_select_issue(callback_query, state)

tests/test_issue_editor.py:232: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/routers/issue_editor/handlers.py:105: in cb_select_issue
    text, keyboard = await format_issue_edit(issue)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

issue = {'db_item': '—', 'index': 2, 'invoice_item': 'Banana pack', 'issue': '❌ Not in database', ...}

    async def format_issue_edit(
        issue: Dict[str, Any]
    ) -> Tuple[str, InlineKeyboardMarkup]:
        """
        Форматирует форму редактирования проблемы.
    
        Args:
            issue: словарь с данными о проблеме
    
        Returns:
            Tuple[str, InlineKeyboardMarkup]: (текст сообщения, клавиатура)
        """
        text = "✏️ *Редактирование*\n\n"
    
        # Добавляем описание проблемы
        text += f"*Проблема:* {issue.get('description', 'Без описания')}\n\n"
    
        # Добавляем текущие значения
        text += "*Текущие значения:*\n"
        for field, value in issue.get("current_values", {}).items():
            text += f"• {field}: {value}\n"
    
        # Создаем клавиатуру
        keyboard = []
    
        # Кнопки для редактирования полей
        for field in issue.get("editable_fields", []):
            keyboard.append([
                InlineKeyboardButton(
                    text=f"✏️ {field}",
                    callback_data=f"{CB_ACTION_PREFIX}{field}"
                )
            ])
    
        # Кнопки навигации
        keyboard.append([
            InlineKeyboardButton(text="◀️ Назад", callback_data=CB_BACK),
>           InlineKeyboardButton(text="❌ Отмена", callback_data=CB_CANCEL)
        ])
E       NameError: name 'CB_CANCEL' is not defined

app/routers/issue_editor/formatters.py:182: NameError
________________________ test_cb_action_with_item_name _________________________

self = <Coroutine test_cb_action_with_item_name>

    def runtest(self) -> None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
>       super().runtest()

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:440: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:907: in inner
    _loop.run_until_complete(task)
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/unittest/mock.py:1351: in patched
    with self.decoration_helper(patched,
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/contextlib.py:117: in __enter__
    return next(self.gen)
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/unittest/mock.py:1316: in decoration_helper
    arg = exit_stack.enter_context(patching)
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/contextlib.py:429: in enter_context
    result = _cm_type.__enter__(cm)
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/unittest/mock.py:1405: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x107effd90>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.routers.issue_editor' (namespace)> does not have the attribute 'get_products_by_name'

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/unittest/mock.py:1378: AttributeError
_________________________ test_cb_action_with_item_qty _________________________

callback_query = <AsyncMock spec='CallbackQuery' id='4440325472'>
state = <aiogram.fsm.context.FSMContext object at 0x108ab1b80>

    @pytest.mark.asyncio
    async def test_cb_action_with_item_qty(callback_query, state):
        """Тест выбора действия изменения количества."""
        callback_query.data = "action_qty"
    
        await cb_action_with_item(callback_query, state)
    
        # Проверяем, что состояние изменилось
>       assert await state.get_state() == InvoiceEditStates.field_input
E       assert <InvoiceEditStates.issue_list: 1> == <InvoiceEditStates.field_input: 4>
E        +  where <InvoiceEditStates.field_input: 4> = InvoiceEditStates.field_input

tests/test_issue_editor.py:271: AssertionError
____________________________ test_cb_select_product ____________________________

self = <Coroutine test_cb_select_product>

    def runtest(self) -> None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
>       super().runtest()

.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:440: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:907: in inner
    _loop.run_until_complete(task)
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py:642: in run_until_complete
    return future.result()
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/unittest/mock.py:1351: in patched
    with self.decoration_helper(patched,
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/contextlib.py:117: in __enter__
    return next(self.gen)
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/unittest/mock.py:1316: in decoration_helper
    arg = exit_stack.enter_context(patching)
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/contextlib.py:429: in enter_context
    result = _cm_type.__enter__(cm)
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/unittest/mock.py:1405: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x107effe20>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.routers.issue_editor' (namespace)> does not have the attribute 'SessionLocal'

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/unittest/mock.py:1378: AttributeError
______________________ test_process_field_input_quantity _______________________

message = <AsyncMock spec='Message' id='4432906128'>
state = <aiogram.fsm.context.FSMContext object at 0x1088ee8b0>

    @pytest.mark.asyncio
    async def test_process_field_input_quantity(message, state):
        """Тест ввода нового количества."""
        # Устанавливаем состояние и поле для редактирования
        await state.update_data(field="quantity")
        await state.set_state(InvoiceEditStates.field_input)
    
        # Устанавливаем текст сообщения
        message.text = "3.5"
    
        # Импортируем функцию здесь, чтобы не мешать другим тестам
>       from app.routers.issue_editor import process_field_input
E       ImportError: cannot import name 'process_field_input' from 'app.routers.issue_editor' (unknown location)

tests/test_issue_editor.py:323: ImportError
________________________ test_clean_name_for_comparison ________________________

    def test_clean_name_for_comparison():
        """Тестирует очистку названия для сравнения."""
        test_cases = [
            ("Test Product", "test product"),
            ("Test-Product", "test product"),
            ("Test_Product", "test product"),
            ("Test.Product", "test product"),
            ("Test  Product", "test product"),
            ("Test Product!", "test product"),
            ("Test Product?", "test product"),
            ("Test Product...", "test product"),
        ]
    
        for input_name, expected in test_cases:
>           assert clean_name_for_comparison(input_name) == expected
E           AssertionError: assert 'test product!' == 'test product'
E             
E             - test product
E             + test product!
E             ?             +

tests/test_issue_editor.py:348: AssertionError
_____________________________ test_is_semifinished _____________________________

    def test_is_semifinished():
        """Тестирует определение полуфабрикатов."""
        semifinished_names = [
            "Полуфабрикат",
            "Полуфабрикат мясной",
            "Полуфабрикат куриный",
            "П/ф",
            "П/ф мясной",
            "П/ф куриный"
        ]
    
        regular_names = [
            "Курица",
            "Мясо",
            "Рыба",
            "Овощи",
            "Фрукты"
        ]
    
        for name in semifinished_names:
>           assert is_semifinished(name) is True
E           AssertionError: assert False is True
E            +  where False = is_semifinished('Полуфабрикат')

tests/test_issue_editor.py:371: AssertionError
_____________________________ test_get_issue_icon ______________________________

sample_issue = {'db_item': 'Test Product (pcs)', 'index': 1, 'invoice_item': 'Test Product (pcs)', 'issue': 'Not in database', ...}

    def test_get_issue_icon(sample_issue: Dict[str, Any]):
        """Тестирует получение иконки для проблемы."""
        # Тестируем разные типы проблем
        test_cases = [
            ("Not in database", "🔴"),
            ("Unit conversion needed", "🟠"),
            ("Possible incorrect match", "🟡"),
            ("Unknown issue", "⚠️")
        ]
    
        for issue_type, expected_icon in test_cases:
            sample_issue["issue"] = issue_type
>           assert get_issue_icon(sample_issue) == expected_icon
E           AssertionError: assert '❓' == '🔴'
E             
E             - 🔴
E             + ❓

tests/test_issue_editor.py:433: AssertionError
___________________________ test_format_issues_list ____________________________

sample_issues = [{'db_item': '—', 'index': 1, 'invoice_item': 'Product 1 (pcs)', 'issue': 'Not in database', ...}, {'db_item': 'Product 2 (g)', 'index': 2, 'invoice_item': 'Product 2 (kg)', 'issue': 'Unit conversion needed', ...}]

    @pytest.mark.asyncio
    async def test_format_issues_list(sample_issues: List[Dict[str, Any]]):
        """Тестирует форматирование списка проблем."""
        message, keyboard = await format_issues_list({"issues": sample_issues})
    
        assert isinstance(message, str)
        assert isinstance(keyboard, InlineKeyboardMarkup)
>       assert "Product 1" in message
E       AssertionError: assert 'Product 1' in '📝 *Список проблем для редактирования*\n\n1. ❓ Без описания\n2. ❓ Без описания\n'

tests/test_issue_editor.py:443: AssertionError
____________________________ test_format_issue_edit ____________________________

sample_issue = {'db_item': 'Test Product (pcs)', 'index': 1, 'invoice_item': 'Test Product (pcs)', 'issue': 'Not in database', ...}

    @pytest.mark.asyncio
    async def test_format_issue_edit(sample_issue: Dict[str, Any]):
        """Тестирует форматирование редактирования проблемы."""
>       message, keyboard = await format_issue_edit(sample_issue)

tests/test_issue_editor.py:451: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

issue = {'db_item': 'Test Product (pcs)', 'index': 1, 'invoice_item': 'Test Product (pcs)', 'issue': 'Not in database', ...}

    async def format_issue_edit(
        issue: Dict[str, Any]
    ) -> Tuple[str, InlineKeyboardMarkup]:
        """
        Форматирует форму редактирования проблемы.
    
        Args:
            issue: словарь с данными о проблеме
    
        Returns:
            Tuple[str, InlineKeyboardMarkup]: (текст сообщения, клавиатура)
        """
        text = "✏️ *Редактирование*\n\n"
    
        # Добавляем описание проблемы
        text += f"*Проблема:* {issue.get('description', 'Без описания')}\n\n"
    
        # Добавляем текущие значения
        text += "*Текущие значения:*\n"
        for field, value in issue.get("current_values", {}).items():
            text += f"• {field}: {value}\n"
    
        # Создаем клавиатуру
        keyboard = []
    
        # Кнопки для редактирования полей
        for field in issue.get("editable_fields", []):
            keyboard.append([
                InlineKeyboardButton(
                    text=f"✏️ {field}",
                    callback_data=f"{CB_ACTION_PREFIX}{field}"
                )
            ])
    
        # Кнопки навигации
        keyboard.append([
            InlineKeyboardButton(text="◀️ Назад", callback_data=CB_BACK),
>           InlineKeyboardButton(text="❌ Отмена", callback_data=CB_CANCEL)
        ])
E       NameError: name 'CB_CANCEL' is not defined

app/routers/issue_editor/formatters.py:182: NameError
___________________________ test_format_field_prompt ___________________________

    def test_format_field_prompt():
        """Тестирует форматирование подсказки для поля."""
        test_cases = [
            ("name", "Test", "Введите новое название товара:\nТекущее значение: Test"),
            ("quantity", "10", "Введите новое количество:\nТекущее значение: 10"),
            ("unit", "pcs", "Введите новую единицу измерения:\nТекущее значение: pcs"),
            ("price", "100", "Введите новую цену:\nТекущее значение: 100")
        ]
    
        for field, current_value, expected in test_cases:
>           assert format_field_prompt(field, current_value) == expected
E           AssertionError: assert '✏️ Введите н...те из списка:' == 'Введите ново...начение: Test'
E             
E             - Введите новое название товара:
E             + ✏️ Введите новое значение для поля *name*
E             + 
E             - Текущее значение: Test
E             + Текущее значение: Test
E             ?                       +
E             + 
E             + Или выберите из списка:

tests/test_issue_editor.py:495: AssertionError
_________________________________ test_cb_back _________________________________

callback_query = <AsyncMock spec='CallbackQuery' id='4437971152'>
state = <aiogram.fsm.context.FSMContext object at 0x10846f340>

    @pytest.mark.asyncio
    async def test_cb_back(callback_query, state):
        """Тест возврата к предыдущему состоянию."""
        # Устанавливаем начальное состояние
        await state.set_state(InvoiceEditStates.issue_edit)
        await state.update_data(previous_state=InvoiceEditStates.issue_list)
    
        callback_query.data = "back"
    
>       await cb_back(callback_query, state)

tests/test_issue_editor.py:507: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

c = <AsyncMock spec='CallbackQuery' id='4437971152'>
state = <aiogram.fsm.context.FSMContext object at 0x10846f340>

    @router.callback_query(F.data == CB_BACK)
    async def cb_back(c: CallbackQuery, state: FSMContext):
        """Обработчик кнопки 'Назад'."""
        current_state = await state.get_state()
        data = await state.get_data()
    
        if current_state == InvoiceEditStates.issue_list:
            # Возвращаемся к итоговой информации
            text, keyboard = await format_summary_message(data)
            await c.message.edit_text(text, reply_markup=keyboard)
            await state.set_state(None)
        elif current_state == InvoiceEditStates.issue_edit:
            # Возвращаемся к списку проблем
            text, keyboard = await format_issues_list(data)
>           await c.message.edit_text(text, reply_markup=keyboard)
E           TypeError: object MagicMock can't be used in 'await' expression

app/routers/issue_editor/handlers.py:53: TypeError
_____________________________ test_cb_change_page ______________________________

callback_query = <AsyncMock spec='CallbackQuery' id='4433134400'>
state = <aiogram.fsm.context.FSMContext object at 0x1087693d0>

    @pytest.mark.asyncio
    async def test_cb_change_page(callback_query, state):
        """Тест переключения страницы в списке проблем."""
        callback_query.data = "page_1"  # Переход на вторую страницу
    
>       await cb_change_page(callback_query, state)

tests/test_issue_editor.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

c = <AsyncMock spec='CallbackQuery' id='4433134400'>
state = <aiogram.fsm.context.FSMContext object at 0x1087693d0>

    @router.callback_query(lambda c: c.data and c.data.startswith(CB_PAGE_PREFIX))
    async def cb_change_page(c: CallbackQuery, state: FSMContext):
        """Обработчик смены страницы."""
        data = await state.get_data()
    
        # Получаем номер страницы из callback_data
        try:
            page = int(c.data[len(CB_PAGE_PREFIX):])
            if page < 0:
                raise ValueError("Invalid page number")
        except ValueError:
            logger.error("Invalid page number in callback", callback_data=c.data)
            await c.answer("Ошибка: неверный номер страницы")
            return
    
        # Форматируем список проблем
        text, keyboard = await format_issues_list(data, page)
    
        # Обновляем сообщение
>       await c.message.edit_text(text, reply_markup=keyboard)
E       TypeError: object MagicMock can't be used in 'await' expression

app/routers/issue_editor/handlers.py:132: TypeError
_____________________________ test_cb_select_unit ______________________________

callback_query = <AsyncMock spec='CallbackQuery' id='4437962464'>
state = <aiogram.fsm.context.FSMContext object at 0x107ee7ee0>

    @pytest.mark.asyncio
    async def test_cb_select_unit(callback_query, state):
        """Тест выбора единицы измерения."""
        callback_query.data = "unit_kg"
    
>       await cb_select_unit(callback_query, state)

tests/test_issue_editor.py:530: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

c = <AsyncMock spec='CallbackQuery' id='4437962464'>
state = <aiogram.fsm.context.FSMContext object at 0x107ee7ee0>

    @router.callback_query((F.data.startswith(CB_UNIT_PREFIX)) & (F.state == InvoiceEditStates.field_input))
    async def cb_select_unit(c: CallbackQuery, state: FSMContext):
        """Обработчик выбора единицы измерения."""
        data = await state.get_data()
        current_issue = data.get("current_issue", {})
        current_field = data.get("current_field")
    
        if current_field != "unit":
>           await c.answer("Ошибка: неверное поле для единицы измерения")
E           TypeError: object MagicMock can't be used in 'await' expression

app/routers/issue_editor/handlers.py:219: TypeError
____________________________ test_cb_search_product ____________________________

callback_query = <AsyncMock spec='CallbackQuery' id='4429238720'>
state = <aiogram.fsm.context.FSMContext object at 0x108ab1be0>

    @pytest.mark.asyncio
    async def test_cb_search_product(callback_query, state):
        """Тест поиска товара."""
        callback_query.data = "search"
    
>       await cb_search_product(callback_query, state)

tests/test_issue_editor.py:546: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

c = <AsyncMock spec='CallbackQuery' id='4429238720'>
state = <aiogram.fsm.context.FSMContext object at 0x108ab1be0>

    @router.callback_query((F.data == CB_SEARCH) & (F.state == InvoiceEditStates.product_select))
    async def cb_search_product(c: CallbackQuery, state: FSMContext):
        """Обработчик поиска товаров."""
>       await c.message.edit_text(
            "🔍 Введите название товара для поиска:",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="◀️ Назад", callback_data=CB_BACK)]
            ])
        )
E       TypeError: object MagicMock can't be used in 'await' expression

app/routers/issue_editor/handlers.py:248: TypeError
__________________ test_process_field_input_invalid_quantity ___________________

message = <AsyncMock spec='Message' id='4440561696'>
state = <aiogram.fsm.context.FSMContext object at 0x1088d7df0>

    @pytest.mark.asyncio
    async def test_process_field_input_invalid_quantity(message, state):
        """Тест обработки некорректного ввода количества."""
        # Устанавливаем состояние и поле для редактирования
        await state.update_data(field="quantity")
        await state.set_state(InvoiceEditStates.field_input)
    
        # Устанавливаем некорректный текст сообщения
        message.text = "invalid"
    
>       await process_field_input(message, state)

tests/test_issue_editor.py:565: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

message = <AsyncMock spec='Message' id='4440561696'>
state = <aiogram.fsm.context.FSMContext object at 0x1088d7df0>

    @router.message(F.state == InvoiceEditStates.field_input)
    async def process_field_input(message: Message, state: FSMContext):
        """Обработчик ввода значения поля."""
        data = await state.get_data()
        current_issue = data.get("current_issue", {})
        current_field = data.get("current_field")
    
        if not current_field:
>           await message.answer("Ошибка: не выбрано поле для редактирования")
E           TypeError: object MagicMock can't be used in 'await' expression

app/routers/issue_editor/handlers.py:263: TypeError
________________________ test_process_field_input_price ________________________

message = <AsyncMock spec='Message' id='4440479872'>
state = <aiogram.fsm.context.FSMContext object at 0x108908ee0>

    @pytest.mark.asyncio
    async def test_process_field_input_price(message, state):
        """Тест ввода новой цены."""
        # Устанавливаем состояние и поле для редактирования
        await state.update_data(field="price")
        await state.set_state(InvoiceEditStates.field_input)
    
        # Устанавливаем текст сообщения
        message.text = "150.50"
    
>       await process_field_input(message, state)

tests/test_issue_editor.py:585: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

message = <AsyncMock spec='Message' id='4440479872'>
state = <aiogram.fsm.context.FSMContext object at 0x108908ee0>

    @router.message(F.state == InvoiceEditStates.field_input)
    async def process_field_input(message: Message, state: FSMContext):
        """Обработчик ввода значения поля."""
        data = await state.get_data()
        current_issue = data.get("current_issue", {})
        current_field = data.get("current_field")
    
        if not current_field:
>           await message.answer("Ошибка: не выбрано поле для редактирования")
E           TypeError: object MagicMock can't be used in 'await' expression

app/routers/issue_editor/handlers.py:263: TypeError
=============================== warnings summary ===============================
.venv/lib/python3.9/site-packages/pydantic/_internal/_config.py:323
.venv/lib/python3.9/site-packages/pydantic/_internal/_config.py:323
  /Users/Denis/Documents/NOTA/NOTAV2/.venv/lib/python3.9/site-packages/pydantic/_internal/_config.py:323: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)

tests/test_fuzzy_match.py::test_fuzzy_match_product
  /Users/Denis/Documents/NOTA/NOTAV2/.venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:769: DeprecationWarning: The event_loop fixture provided by pytest-asyncio has been redefined in
  /Users/Denis/Documents/NOTA/NOTAV2/tests/conftest.py:19
  Replacing the event_loop fixture with a custom implementation is deprecated
  and will lead to errors in the future.
  If you want to request an asyncio event loop with a scope other than function
  scope, use the "scope" argument to the asyncio mark when marking the tests.
  If you want to return different types of event loops, use the event_loop_policy
  fixture.
  
    warnings.warn(

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/test_dates.py::test_convert_timezone - ValueError: Not naive dat...
FAILED tests/test_fuzzy_match.py::test_fuzzy_match_product - ConnectionRefuse...
FAILED tests/test_gpt_combined.py::test_process_invoice - AttributeError: <mo...
FAILED tests/test_issue_editor.py::test_cb_select_issue - NameError: name 'CB...
FAILED tests/test_issue_editor.py::test_cb_action_with_item_name - AttributeE...
FAILED tests/test_issue_editor.py::test_cb_action_with_item_qty - assert <Inv...
FAILED tests/test_issue_editor.py::test_cb_select_product - AttributeError: <...
FAILED tests/test_issue_editor.py::test_process_field_input_quantity - Import...
FAILED tests/test_issue_editor.py::test_clean_name_for_comparison - Assertion...
FAILED tests/test_issue_editor.py::test_is_semifinished - AssertionError: ass...
FAILED tests/test_issue_editor.py::test_get_issue_icon - AssertionError: asse...
FAILED tests/test_issue_editor.py::test_format_issues_list - AssertionError: ...
FAILED tests/test_issue_editor.py::test_format_issue_edit - NameError: name '...
FAILED tests/test_issue_editor.py::test_format_field_prompt - AssertionError:...
FAILED tests/test_issue_editor.py::test_cb_back - TypeError: object MagicMock...
FAILED tests/test_issue_editor.py::test_cb_change_page - TypeError: object Ma...
FAILED tests/test_issue_editor.py::test_cb_select_unit - TypeError: object Ma...
FAILED tests/test_issue_editor.py::test_cb_search_product - TypeError: object...
FAILED tests/test_issue_editor.py::test_process_field_input_invalid_quantity
FAILED tests/test_issue_editor.py::test_process_field_input_price - TypeError...
ERROR tests/test_integration.py::test_full_invoice_creation_flow - ModuleNotF...
ERROR tests/test_integration.py::test_product_search_by_alias - ModuleNotFoun...
ERROR tests/test_integration.py::test_cascade_delete_flow - ModuleNotFoundErr...
ERROR tests/test_invoice.py::test_invoice_creation
ERROR tests/test_invoice.py::test_invoice_supplier_relationship
ERROR tests/test_invoice.py::test_invoice_items_relationship
ERROR tests/test_invoice.py::test_invoice_item_product_relationship
ERROR tests/test_invoice.py::test_invoice_str_representation
ERROR tests/test_invoice.py::test_invoice_item_str_representation
ERROR tests/test_invoice.py::test_product_name_lookup_creation
ERROR tests/test_invoice.py::test_product_name_lookup_product_relationship
ERROR tests/test_invoice.py::test_product_name_lookup_str_representation
ERROR tests/test_invoice.py::test_product_name_lookup_unique_alias
ERROR tests/test_invoice.py::test_invoice_total_amount - ModuleNotFoundError:...
ERROR tests/test_invoice.py::test_invoice_validation - ModuleNotFoundError: N...
ERROR tests/test_invoice.py::test_invoice_cascade_delete - ModuleNotFoundErro...
ERROR tests/test_invoice_item.py::test_invoice_item_creation
ERROR tests/test_invoice_item.py::test_invoice_item_string_representation
ERROR tests/test_invoice_item.py::test_invoice_item_invoice_relationship - Mo...
ERROR tests/test_invoice_item.py::test_invoice_item_product_relationship
ERROR tests/test_invoice_item.py::test_invoice_item_validation - ModuleNotFou...
ERROR tests/test_invoice_item.py::test_invoice_item_total_amount
ERROR tests/test_invoice_item.py::test_invoice_item_unit_validation - ModuleN...
ERROR tests/test_invoice_item.py::test_invoice_item_quantity_precision - Modu...
ERROR tests/test_invoice_item.py::test_invoice_item_price_precision - ModuleN...
ERROR tests/test_invoice_item.py::test_invoice_item_total_amount_precision
ERROR tests/test_invoice_item.py::test_invoice_item_update - ModuleNotFoundEr...
ERROR tests/test_invoice_item.py::test_invoice_item_edge_cases - ModuleNotFou...
ERROR tests/test_invoice_item.py::test_invoice_item_invalid_decimal - ModuleN...
ERROR tests/test_invoice_item.py::test_invoice_item_foreign_key_constraints
ERROR tests/test_invoice_item.py::test_invoice_item_name_length - ModuleNotFo...
ERROR tests/test_invoice_item.py::test_invoice_item_comment_length - ModuleNo...
ERROR tests/test_issue_editor.py::test_get_products_by_name
ERROR tests/test_issue_editor.py::test_save_product_match
ERROR tests/test_issue_editor.py::test_format_product_select
ERROR tests/test_performance.py::test_bulk_insert_performance - ModuleNotFoun...
ERROR tests/test_performance.py::test_search_performance - ModuleNotFoundErro...
ERROR tests/test_performance.py::test_invoice_calculation_performance - Modul...
ERROR tests/test_performance.py::test_concurrent_operations_performance - Mod...
ERROR tests/test_performance.py::test_index_performance - ModuleNotFoundError...
ERROR tests/test_performance.py::test_complex_query_performance - ModuleNotFo...
ERROR tests/test_performance.py::test_memory_usage_performance - ModuleNotFou...
ERROR tests/test_performance.py::test_transaction_performance - ModuleNotFoun...
ERROR tests/test_product.py::test_product_creation
ERROR tests/test_product.py::test_product_string_representation
ERROR tests/test_product.py::test_product_name_lookup_relationship
ERROR tests/test_product.py::test_product_validation - ModuleNotFoundError: N...
ERROR tests/test_product.py::test_product_unique_code - ModuleNotFoundError: ...
ERROR tests/test_product.py::test_product_cascade_delete - ModuleNotFoundErro...
ERROR tests/test_product_name_lookup.py::test_product_name_lookup_creation
ERROR tests/test_product_name_lookup.py::test_product_name_lookup_string_representation
ERROR tests/test_product_name_lookup.py::test_product_name_lookup_product_relationship
ERROR tests/test_product_name_lookup.py::test_product_name_lookup_validation
ERROR tests/test_product_name_lookup.py::test_product_name_lookup_unique_alias
ERROR tests/test_product_name_lookup.py::test_product_name_lookup_case_insensitive
ERROR tests/test_product_name_lookup.py::test_product_name_lookup_alias_length
ERROR tests/test_product_name_lookup.py::test_product_name_lookup_alias_format
ERROR tests/test_product_name_lookup.py::test_product_name_lookup_comment_length
ERROR tests/test_product_name_lookup.py::test_product_name_lookup_update - Mo...
ERROR tests/test_product_name_lookup.py::test_product_name_lookup_fuzzy_search
ERROR tests/test_product_name_lookup.py::test_product_name_lookup_cascade_delete
ERROR tests/test_product_name_lookup.py::test_product_name_lookup_edge_cases
ERROR tests/test_product_name_lookup.py::test_product_name_lookup_special_characters
ERROR tests/test_product_name_lookup.py::test_product_name_lookup_foreign_key_constraints
ERROR tests/test_product_name_lookup.py::test_product_name_lookup_duplicate_aliases_different_products
ERROR tests/test_product_name_lookup.py::test_product_name_lookup_case_sensitive_unique
ERROR tests/test_supplier.py::test_supplier_creation - ModuleNotFoundError: N...
ERROR tests/test_supplier.py::test_supplier_string_representation - ModuleNot...
ERROR tests/test_supplier.py::test_supplier_invoices_relationship - ModuleNot...
ERROR tests/test_supplier.py::test_supplier_validation - ModuleNotFoundError:...
ERROR tests/test_supplier.py::test_supplier_unique_inn - ModuleNotFoundError:...
ERROR tests/test_supplier.py::test_supplier_cascade_delete - ModuleNotFoundEr...
============= 20 failed, 23 passed, 3 warnings, 72 errors in 7.86s =============
