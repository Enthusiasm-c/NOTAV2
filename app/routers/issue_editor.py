"""
–£–ª—É—á—à–µ–Ω–Ω—ã–π UI-—Ä–µ–¥–∞–∫—Ç–æ—Ä —Å–ø–æ—Ä–Ω—ã—Ö –ø–æ–∑–∏—Ü–∏–π –¥–ª—è Nota V2.

–û—Å–Ω–æ–≤–Ω—ã–µ —É–ª—É—á—à–µ–Ω–∏—è:
1. –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–µ—Ç–∞–ª—å–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –ø—Ä–æ–±–ª–µ–º–Ω—ã—Ö –ø–æ–∑–∏—Ü–∏—è—Ö —Å—Ä–∞–∑—É
2. –ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–µ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ–º —Ç–æ–≤–∞—Ä–æ–≤ –∏–∑ –±–∞–∑—ã
3. –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –µ–¥–∏–Ω–∏—Ü –∏–∑–º–µ—Ä–µ–Ω–∏—è
4. –ú–∞—Å—Å–æ–≤–æ–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏—Ö —Ç–æ–≤–∞—Ä–æ–≤
"""

from __future__ import annotations

import re
import math
import structlog
from decimal import Decimal
from typing import Any, Dict, List, Optional, Tuple

from aiogram import Router, F, Bot
from aiogram.types import (
    Message, 
    CallbackQuery, 
    InlineKeyboardMarkup, 
    InlineKeyboardButton,
    ForceReply
)
from aiogram.filters import Text
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup

from sqlalchemy import select, func, insert, update, delete
from sqlalchemy.ext.asyncio import AsyncSession

from app.db import SessionLocal
from app.models.product import Product
from app.models.invoice import Invoice
from app.models.invoice_item import InvoiceItem
from app.models.product_name_lookup import ProductNameLookup
from app.models.invoice_state import InvoiceEditStates

# –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –º–æ–¥—É–ª–∏ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –µ–¥–∏–Ω–∏—Ü –∏–∑–º–µ—Ä–µ–Ω–∏—è
from app.utils.unit_converter import normalize_unit, is_compatible_unit, convert
from app.config import settings
from app.utils.change_logger import log_change, log_delete, log_save_new
from app.utils.keyboards import kb_field_selector, kb_after_edit, FieldCallback, IssueCallback

logger = structlog.get_logger()
router = Router(name="issue_editor")

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# –†–∞–∑–º–µ—Ä —Å—Ç—Ä–∞–Ω–∏—Ü—ã –¥–ª—è –ø–∞–≥–∏–Ω–∞—Ü–∏–∏
PAGE_SIZE = 5

# –ü—Ä–µ—Ñ–∏–∫—Å—ã –¥–ª—è callback-–¥–∞–Ω–Ω—ã—Ö
CB_ISSUE_PREFIX = "issue:"
CB_PAGE_PREFIX = "page:"
CB_PRODUCT_PREFIX = "product:"
CB_ACTION_PREFIX = "action:"
CB_UNIT_PREFIX = "unit:"
CB_CONVERT_PREFIX = "convert:"
CB_ADD_NEW = "add_new"
CB_ADD_ALL = "add_all_missing"
CB_SEARCH = "search"
CB_BACK = "back"
CB_CANCEL = "cancel"
CB_CONFIRM = "inv_ok"        # –î–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º –∫–æ–¥–æ–º
CB_REVIEW = "review"

# –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –¥–ª—è –ø–æ–ª—É—Ñ–∞–±—Ä–∏–∫–∞—Ç–æ–≤
SEMIFINISHED_PATTERNS = [r's/f', r's/finished', r'semi.?finished', r'semi.?fabricated']
MIN_CONFIDENCE_FOR_LEARNING = 0.90  # –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å –¥–ª—è –∞–≤—Ç–æ–æ–±—É—á–µ–Ω–∏—è

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def clean_name_for_comparison(name: str) -> str:
    """
    –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ—Ç —Å—Ç—Ä–æ–∫—É –Ω–∞–∑–≤–∞–Ω–∏—è –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è:
    - –ü—Ä–∏–≤–æ–¥–∏—Ç –∫ –Ω–∏–∂–Ω–µ–º—É —Ä–µ–≥–∏—Å—Ç—Ä—É
    - –£–±–∏—Ä–∞–µ—Ç –ª–∏—à–Ω–∏–µ –ø—Ä–æ–±–µ–ª—ã
    - –£–±–∏—Ä–∞–µ—Ç –∑–Ω–∞–∫–∏ –ø—É–Ω–∫—Ç—É–∞—Ü–∏–∏
    """
    if not name:
        return ""
    
    # –ü—Ä–∏–≤–æ–¥–∏–º –∫ –Ω–∏–∂–Ω–µ–º—É —Ä–µ–≥–∏—Å—Ç—Ä—É
    name = name.lower()
    
    # –£–¥–∞–ª—è–µ–º –ª–∏—à–Ω–∏–µ –ø—Ä–æ–±–µ–ª—ã
    name = re.sub(r'\s+', ' ', name).strip()
    
    # –£–¥–∞–ª—è–µ–º –∏–ª–∏ –∑–∞–º–µ–Ω—è–µ–º –∑–Ω–∞–∫–∏ –ø—É–Ω–∫—Ç—É–∞—Ü–∏–∏
    name = re.sub(r'[.,;:\-_()]', ' ', name)
    name = re.sub(r'\s+', ' ', name).strip()
    
    return name


def is_semifinished(name: str) -> bool:
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ç–æ–≤–∞—Ä –ø–æ–ª—É—Ñ–∞–±—Ä–∏–∫–∞—Ç–æ–º –ø–æ –º–∞—Ä–∫–µ—Ä–∞–º –≤ –Ω–∞–∑–≤–∞–Ω–∏–∏.
    
    :param name: –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞
    :return: True –µ—Å–ª–∏ —ç—Ç–æ –ø–æ–ª—É—Ñ–∞–±—Ä–∏–∫–∞—Ç, –∏–Ω–∞—á–µ False
    """
    name_lower = name.lower()
    return any(re.search(pattern, name_lower) for pattern in SEMIFINISHED_PATTERNS)


async def get_products_by_name(
    session: AsyncSession, 
    name_query: str, 
    limit: int = 3,
    threshold: float = 0.7,
    exclude_semifinished: bool = True
) -> List[Dict[str, Any]]:
    """
    –ò—â–µ—Ç —Ç–æ–≤–∞—Ä—ã –ø–æ —á–∞—Å—Ç–∏ –∏–º–µ–Ω–∏ —Å —É—á–µ—Ç–æ–º –ø–æ–ª—É—Ñ–∞–±—Ä–∏–∫–∞—Ç–æ–≤.
    
    :param session: –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è —Å–µ—Å—Å–∏—è SQLAlchemy
    :param name_query: —Å—Ç—Ä–æ–∫–∞ –ø–æ–∏—Å–∫–∞
    :param limit: –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 3)
    :param threshold: –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –ø–æ—Ä–æ–≥ —Å—Ö–æ–∂–µ—Å—Ç–∏ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 0.7)
    :param exclude_semifinished: –∏—Å–∫–ª—é—á–∏—Ç—å –ø–æ–ª—É—Ñ–∞–±—Ä–∏–∫–∞—Ç—ã –∏–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
    :return: —Å–ø–∏—Å–æ–∫ —Ç–æ–≤–∞—Ä–æ–≤
    """
    if not name_query:
        return []
    
    # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –∑–∞–ø—Ä–æ—Å
    normalized_query = clean_name_for_comparison(name_query)
    
    # –ü—ã—Ç–∞–µ–º—Å—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ñ—É–Ω–∫—Ü–∏—é find_similar_products –∏–∑ fuzzy_match
    try:
        from app.routers.fuzzy_match import find_similar_products
        products = await find_similar_products(
            session, 
            normalized_query, 
            limit=limit, 
            threshold=threshold
        )
        
        # –§–∏–ª—å—Ç—Ä—É–µ–º –ø–æ–ª—É—Ñ–∞–±—Ä–∏–∫–∞—Ç—ã –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
        if exclude_semifinished:
            products = [p for p in products if not is_semifinished(p["name"])]
        
        return products
    except ImportError:
        logger.warning("fuzzy_match module not found, using fallback search")
    
    # –†–µ–∑–µ—Ä–≤–Ω—ã–π –ø—É—Ç—å: –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä—è–º–æ–π SQL –∑–∞–ø—Ä–æ—Å
    stmt = (
        select(Product.id, Product.name, Product.unit)
        .where(func.lower(Product.name).like(f"%{normalized_query}%"))
        .order_by(Product.name)
        .limit(limit * 2)  # –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –±–æ–ª—å—à–µ –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏
    )
    
    result = await session.execute(stmt)
    products = []
    
    for row in result:
        product_id, name, unit = row
        
        # –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ–ª—É—Ñ–∞–±—Ä–∏–∫–∞—Ç–æ–≤ –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
        if exclude_semifinished and is_semifinished(name):
            continue
        
        # –í—ã—á–∏—Å–ª—è–µ–º —Å—Ç–µ–ø–µ–Ω—å —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è
        name_normalized = clean_name_for_comparison(name)
        
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –±–æ–ª–µ–µ —Ç–æ—á–Ω–æ–µ –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ —Å—Ö–æ–∂–µ—Å—Ç–∏
        try:
            from rapidfuzz import fuzz
            score = fuzz.token_sort_ratio(normalized_query, name_normalized) / 100.0
        except ImportError:
            # –ü—Ä–æ—Å—Ç–æ–π —Ä–∞—Å—á–µ—Ç —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è, –µ—Å–ª–∏ rapidfuzz –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω
            if normalized_query == name_normalized:
                score = 1.0
            elif normalized_query in name_normalized.split():
                score = 0.85
            elif normalized_query in name_normalized:
                score = 0.75
            else:
                score = 0.65
        
        # –û—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤—ã–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –Ω–∏–∂–µ –ø–æ—Ä–æ–≥–∞ —Å—Ö–æ–∂–µ—Å—Ç–∏
        if score < threshold:
            continue
            
        products.append({
            "id": product_id,
            "name": name,
            "unit": unit,
            "confidence": score
        })
    
    # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —É–±—ã–≤–∞–Ω–∏—é —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç–∏
    products.sort(key=lambda p: p["confidence"], reverse=True)
    
    # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
    return products[:limit]


async def save_product_match(
    session: AsyncSession, 
    parsed_name: str, 
    product_id: int
) -> bool:
    """
    –°–æ—Ö—Ä–∞–Ω—è–µ—Ç —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –Ω–∞–∑–≤–∞–Ω–∏—è —Ç–æ–≤–∞—Ä–∞ —Å ID –¥–ª—è –±—É–¥—É—â–µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è.
    
    :param session: –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è —Å–µ—Å—Å–∏—è SQLAlchemy
    :param parsed_name: —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞
    :param product_id: ID —Ç–æ–≤–∞—Ä–∞ –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
    :return: True –µ—Å–ª–∏ —É—Å–ø–µ—à–Ω–æ, –∏–Ω–∞—á–µ False
    """
    if not parsed_name or not product_id:
        return False
    
    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞
        res = await session.execute(
            select(Product.id).where(Product.id == product_id)
        )
        if not res.scalar_one_or_none():
            logger.warning("Cannot add lookup entry - product does not exist", 
                          product_id=product_id)
            return False
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ—Ç –ª–∏ —É–∂–µ —Ç–∞–∫–æ–≥–æ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è
        res = await session.execute(
            select(ProductNameLookup.id).where(
                ProductNameLookup.alias == parsed_name
            )
        )
        existing_id = res.scalar_one_or_none()
        
        if existing_id:
            # –û–±–Ω–æ–≤–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–µ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ
            await session.execute(
                update(ProductNameLookup)
                .where(ProductNameLookup.id == existing_id)
                .values(product_id=product_id)
            )
            logger.info("Updated existing lookup entry", 
                       lookup_id=existing_id, 
                       parsed_name=parsed_name, 
                       product_id=product_id)
        else:
            # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤–æ–µ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ
            stmt = insert(ProductNameLookup).values(
                alias=parsed_name,
                product_id=product_id
            )
            await session.execute(stmt)
            logger.info("Added new lookup entry", 
                       parsed_name=parsed_name, 
                       product_id=product_id)
        
        # –ö–æ–º–º–∏—Ç–∏–º –∏–∑–º–µ–Ω–µ–Ω–∏—è
        await session.commit()
        return True
    
    except Exception as e:
        await session.rollback()
        logger.error("Failed to save product match", 
                    error=str(e), 
                    parsed_name=parsed_name, 
                    product_id=product_id)
        return False

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –§—É–Ω–∫—Ü–∏–∏ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è UI ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

async def format_summary_message(data: Dict[str, Any]) -> Tuple[str, InlineKeyboardMarkup]:
    """
    –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ —Å–æ —Å–≤–æ–¥–∫–æ–π –Ω–∞–∫–ª–∞–¥–Ω–æ–π.
    
    :param data: –¥–∞–Ω–Ω—ã–µ –Ω–∞–∫–ª–∞–¥–Ω–æ–π
    :return: —Ç–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è –∏ –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞
    """
    # –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏–∏ –∏ –ø—Ä–æ–±–ª–µ–º—ã
    positions = data.get("positions", [])
    active_positions = [p for p in positions if not p.get("deleted", False)]
    
    total_positions = len(active_positions)
    
    if "issues" in data:
        issues = data["issues"]
    else:
        # –ï—Å–ª–∏ issues –Ω–µ –ø–µ—Ä–µ–¥–∞–Ω, –ø—ã—Ç–∞–µ–º—Å—è –≤—ã–¥–µ–ª–∏—Ç—å –ø—Ä–æ–±–ª–µ–º–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏
        issues = []
        for pos in active_positions:
            if pos.get("match_id") is None or pos.get("confidence", 1.0) < 0.85:
                issues.append({"index": positions.index(pos) + 1, "original": pos})
    
    problematic_count = len(issues)
    matched_count = total_positions - problematic_count
    
    # –ü–æ–ª—É—á–∞–µ–º –æ—Å–Ω–æ–≤–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –Ω–∞–∫–ª–∞–¥–Ω–æ–π
    supplier = data.get("supplier", "Unknown")
    date = data.get("date", "Unknown")
    invoice_number = data.get("number", "")
    
    # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Å–≤–æ–¥–∫—É
    message = f"üìÑ <b>Invoice draft</b>\n\n"
    message += f"üè∑Ô∏è <b>Supplier:</b> {supplier}\n"
    message += f"üìÖ <b>Date:</b> {date}{f' ‚Ññ{invoice_number}' if invoice_number else ''}\n\n"
    message += f"<b>Items parsed:</b> {total_positions}  \n"
    message += f"‚úÖ <b>Matched:</b> {matched_count}  \n"
    
    if problematic_count > 0:
        message += f"‚ùì <b>Need review:</b> {problematic_count}"
    else:
        message += "‚úÖ <b>All items matched!</b>"
    
    # –°–æ–∑–¥–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å –∫–Ω–æ–ø–∫–∞–º–∏
    keyboard = []
    
    if problematic_count > 0:
        keyboard.append([
            InlineKeyboardButton(text="‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å", callback_data="inv_ok"),
            InlineKeyboardButton(text=f"üîç –ò—Å–ø—Ä–∞–≤–∏—Ç—å ({problematic_count})", callback_data="inv_edit")
        ])
    else:
        keyboard.append([
            InlineKeyboardButton(text="‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –∏ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å", callback_data="inv_ok")
        ])
    
    return message, InlineKeyboardMarkup(inline_keyboard=keyboard)


def get_issue_icon(issue: Dict[str, Any]) -> str:
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∏–∫–æ–Ω–∫—É –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞ –ø—Ä–æ–±–ª–µ–º—ã.
    """
    issue_type = issue.get("issue", "")
    original = issue.get("original", {})
    
    if "Not in database" in issue_type:
        return "‚ö†"
    elif "incorrect match" in issue_type or original.get("confidence", 1.0) < 0.85:
        return "‚ùî"
    elif "Unit" in issue_type:
        return "üîÑ"
    elif original.get("ignored", False):
        return "‚ùå"
    else:
        return "‚ùì"


async def format_issues_list(
    data: Dict[str, Any], 
    page: int = 0
) -> Tuple[str, InlineKeyboardMarkup]:
    """
    –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç —Å–ø–∏—Å–æ–∫ –ø—Ä–æ–±–ª–µ–º–Ω—ã—Ö –ø–æ–∑–∏—Ü–∏–π —Å –ø–∞–≥–∏–Ω–∞—Ü–∏–µ–π.
    
    :param data: –¥–∞–Ω–Ω—ã–µ –Ω–∞–∫–ª–∞–¥–Ω–æ–π —Å –ø—Ä–æ–±–ª–µ–º–Ω—ã–º–∏ –ø–æ–∑–∏—Ü–∏—è–º–∏
    :param page: –Ω–æ–º–µ—Ä —Å—Ç—Ä–∞–Ω–∏—Ü—ã (–Ω–∞—á–∏–Ω–∞—è —Å 0)
    :return: —Ç–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è –∏ –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞
    """
    issues = data.get("issues", [])
    
    # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –ø–∞–≥–∏–Ω–∞—Ü–∏—é
    total_pages = math.ceil(len(issues) / PAGE_SIZE)
    page = max(0, min(page, total_pages - 1))
    
    # –°–æ–∑–¥–∞–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫
    message = f"‚ùó <b>–ü–æ–∑–∏—Ü–∏–∏ —Ç—Ä–µ–±—É—é—â–∏–µ –≤–Ω–∏–º–∞–Ω–∏—è ‚Äî —Å—Ç—Ä–∞–Ω–∏—Ü–∞ {page+1} / {total_pages}</b>\n\n<code>"
    
    # –§–æ—Ä–º–∏—Ä—É–µ–º —Ç–∞–±–ª–∏—Ü—É —Å –Ω–æ–≤—ã–º –¥–∏–∑–∞–π–Ω–æ–º
    # –ó–∞–≥–æ–ª–æ–≤–æ–∫ —Ç–∞–±–ª–∏—Ü—ã —Å 4 –∫–æ–ª–æ–Ω–∫–∞–º–∏: ‚Ññ, –ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ, –ö–æ–ª-–≤–æ/–ï–¥., –¶–µ–Ω–∞
    message += f"{'‚Ññ':<3} {'–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ':<20} {'–ö–æ–ª-–≤–æ/–ï–¥.':<12} {'–¶–µ–Ω–∞':<8}\n"
    message += f"{'-'*3} {'-'*20} {'-'*12} {'-'*8}\n"
    
    # –ü–æ–ª—É—á–∞–µ–º –ø–æ–∑–∏—Ü–∏–∏ –¥–ª—è —Ç–µ–∫—É—â–µ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã
    start_idx = page * PAGE_SIZE
    end_idx = min(start_idx + PAGE_SIZE, len(issues))
    current_issues = issues[start_idx:end_idx]
    
    # –°—Ç—Ä–æ–∫–∏ —Ç–∞–±–ª–∏—Ü—ã
    for issue in current_issues:
        index = issue.get("index", 0)
        original = issue.get("original", {})
        
        # –ü–æ–ª—É—á–∞–µ–º –Ω–∞–∑–≤–∞–Ω–∏–µ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
        item_name = original.get("name", "Unknown")
        
        # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–ª–∏–Ω—É –Ω–∞–∑–≤–∞–Ω–∏—è
        if len(item_name) > 20:
            item_name = item_name[:17] + "..."
        
        # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Å—Ç–æ–ª–±–µ—Ü –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∏ –µ–¥–∏–Ω–∏—Ü—ã –∏–∑–º–µ—Ä–µ–Ω–∏—è
        quantity = original.get("quantity", 0)
        unit = original.get("unit", "")
        qty_unit = f"{quantity} {unit}".strip()
        
        # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Å—Ç–æ–ª–±–µ—Ü —Ü–µ–Ω—ã
        price = original.get("price", "")
        price_display = ""
        if price:
            try:
                price_float = float(price)
                price_display = f"{price_float:,.2f}"
            except (ValueError, TypeError):
                price_display = str(price)
        
        # –ü–æ–ª—É—á–∞–µ–º –∏–∫–æ–Ω–∫—É –ø—Ä–æ–±–ª–µ–º—ã
        icon = get_issue_icon(issue)
        
        # –î–æ–±–∞–≤–ª—è–µ–º —Å—Ç—Ä–æ–∫—É –≤ —Ç–∞–±–ª–∏—Ü—É
        message += f"{index:<3} {item_name:<20} {qty_unit:<12} {price_display:<8} {icon}\n"
    
    message += "</code>"
    
    # –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é
    message += "\n\n–ù–∞–∂–º–∏—Ç–µ –Ω–∞ –ø–æ–∑–∏—Ü–∏—é –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –ø–∞–≥–∏–Ω–∞—Ü–∏–∏."
    
    # –°–æ–∑–¥–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å –∫–Ω–æ–ø–∫–∞–º–∏ –¥–ª—è –ø–æ–∑–∏—Ü–∏–π
    buttons = []
    
    # –ö–Ω–æ–ø–∫–∏ –¥–ª—è –∫–∞–∂–¥–æ–π –ø–æ–∑–∏—Ü–∏–∏
    for issue in current_issues:
        index = issue.get("index", 0)
        original = issue.get("original", {})
        name = original.get("name", "")[:15]
        
        issue_type = issue.get("issue", "")
        icon = get_issue_icon(issue)
                
        btn_text = f"{index}. {icon} {name}"
        buttons.append([
            InlineKeyboardButton(text=btn_text, callback_data=f"{CB_ISSUE_PREFIX}{index}")
        ])
    
    # –î–æ–±–∞–≤–ª—è–µ–º –∫–Ω–æ–ø–∫–∏ –ø–∞–≥–∏–Ω–∞—Ü–∏–∏
    pagination_row = []
    
    if page > 0:
        pagination_row.append(
            InlineKeyboardButton(text="‚óÄÔ∏è –ü—Ä–µ–¥", callback_data=f"{CB_PAGE_PREFIX}{page-1}")
        )
    
    if any("Not in database" in issue.get("issue", "") for issue in issues):
        pagination_row.append(
            InlineKeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –≤—Å–µ", callback_data=CB_ADD_ALL)
        )
    
    if page < total_pages - 1:
        pagination_row.append(
            InlineKeyboardButton(text="–°–ª–µ–¥ ‚ñ∂Ô∏è", callback_data=f"{CB_PAGE_PREFIX}{page+1}")
        )
    
    if pagination_row:
        buttons.append(pagination_row)
    
    # –î–æ–±–∞–≤–ª—è–µ–º –∫–Ω–æ–ø–∫—É "–ì–æ—Ç–æ–≤–æ"
    buttons.append([
        InlineKeyboardButton(text="‚úÖ –ì–æ—Ç–æ–≤–æ", callback_data=CB_CONFIRM)
    ])
    
    return message, InlineKeyboardMarkup(inline_keyboard=buttons)


async def format_issue_edit(
    issue: Dict[str, Any]
) -> Tuple[str, InlineKeyboardMarkup]:
    """
    –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –ø—Ä–æ–±–ª–µ–º–Ω–æ–π –ø–æ–∑–∏—Ü–∏–∏.
    
    :param issue: –¥–∞–Ω–Ω—ã–µ –æ –ø—Ä–æ–±–ª–µ–º–Ω–æ–π –ø–æ–∑–∏—Ü–∏–∏
    :return: —Ç–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è –∏ –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞
    """
    original = issue.get("original", {})
    
    # –ü–æ–ª—É—á–∞–µ–º –æ—Å–Ω–æ–≤–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –æ –ø–æ–∑–∏—Ü–∏–∏
    index = issue.get("index", 0)
    name = original.get("name", "Unknown")
    quantity = original.get("quantity", 0)
    unit = original.get("unit", "")
    price = original.get("price", 0)
    sum_val = original.get("sum", 0)
    
    # –ü–æ–ª—É—á–∞–µ–º —Ç–∏–ø –ø—Ä–æ–±–ª–µ–º—ã
    issue_type = issue.get("issue", "Unknown issue")
    icon = get_issue_icon(issue)
    
    if "Not in database" in issue_type:
        issue_description = "–¢–æ–≤–∞—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö"
    elif "incorrect match" in issue_type:
        issue_description = "–í–æ–∑–º–æ–∂–Ω–æ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ"
    elif "Unit" in issue_type:
        issue_description = "–ù–µ—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ –µ–¥–∏–Ω–∏—Ü –∏–∑–º–µ—Ä–µ–Ω–∏—è"
    else:
        issue_description = issue_type
    
    # –§–æ—Ä–º–∏—Ä—É–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫
    message = f"{icon} <b>–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ #{index}</b>\n\n"
    
    # –î–µ—Ç–∞–ª–∏ –ø–æ–∑–∏—Ü–∏–∏
    message += f"<b>–ù–∞–∑–≤–∞–Ω–∏–µ:</b> {name}\n"
    message += f"<b>–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ:</b> {quantity} {unit}\n"
    
    if price:
        try:
            price_float = float(price)
            message += f"<b>–¶–µ–Ω–∞:</b> {price_float:,.2f}\n"
        except (ValueError, TypeError):
            message += f"<b>–¶–µ–Ω–∞:</b> {price}\n"
    
    if sum_val:
        try:
            sum_float = float(sum_val)
            message += f"<b>–°—É–º–º–∞:</b> {sum_float:,.2f}\n"
        except (ValueError, TypeError):
            message += f"<b>–°—É–º–º–∞:</b> {sum_val}\n"
    
    # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø—Ä–æ–±–ª–µ–º–µ
    message += f"\n<b>–ü—Ä–æ–±–ª–µ–º–∞:</b> {issue_description}\n"
    
    # –ï—Å–ª–∏ –µ—Å—Ç—å –¥–∞–Ω–Ω—ã–µ –æ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–Ω–æ–º —Ç–æ–≤–∞—Ä–µ, –¥–æ–±–∞–≤–ª—è–µ–º –∏—Ö
    if "product" in issue:
        product = issue["product"]
        message += f"\n<b>–°–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –≤ –±–∞–∑–µ:</b>\n"
        message += f"<b>‚Üí –ù–∞–∑–≤–∞–Ω–∏–µ:</b> {product.name}\n"
        message += f"<b>‚Üí –ï–¥–∏–Ω–∏—Ü–∞:</b> {product.unit}\n"
    
    # –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è
    message += "\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ –¥–ª—è –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø—Ä–æ–±–ª–µ–º—ã:"
    
    # –°–æ–∑–¥–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É
    buttons = []
    
    # –ü–µ—Ä–≤—ã–π —Ä—è–¥ - –æ—Å–Ω–æ–≤–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è
    buttons.append([
        InlineKeyboardButton(text="‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å", callback_data=f"{CB_ACTION_PREFIX}edit_name")
    ])
    
    buttons.append([
        InlineKeyboardButton(text="üì¶ –¢–æ–≤–∞—Ä", callback_data=f"{CB_ACTION_PREFIX}name"),
        InlineKeyboardButton(text="üî¢ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ", callback_data=f"{CB_ACTION_PREFIX}qty"),
        InlineKeyboardButton(text="üìè –ï–¥–∏–Ω–∏—Ü–∞", callback_data=f"{CB_ACTION_PREFIX}unit")
    ])
    
    # –î–æ–±–∞–≤–ª—è–µ–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞ –ø—Ä–æ–±–ª–µ–º—ã
    additional_row = []
    
    if "Not in database" in issue_type:
        additional_row.append(
            InlineKeyboardButton(text="‚ûï –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π", callback_data=f"{CB_ACTION_PREFIX}add_new")
        )
    
    if "Unit" in issue_type and "product" in issue:
        additional_row.append(
            InlineKeyboardButton(text="üîÑ –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å", callback_data=f"{CB_ACTION_PREFIX}convert")
        )
    
    if additional_row:
        buttons.append(additional_row)
    
    # –î–æ–±–∞–≤–ª—è–µ–º –∫–Ω–æ–ø–∫–∏ —É–¥–∞–ª–µ–Ω–∏—è –∏ –≤–æ–∑–≤—Ä–∞—Ç–∞
    buttons.append([
        InlineKeyboardButton(text="üóëÔ∏è –£–¥–∞–ª–∏—Ç—å", callback_data=f"{CB_ACTION_PREFIX}delete"),
        InlineKeyboardButton(text="‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data=CB_BACK)
    ])
    
    return message, InlineKeyboardMarkup(inline_keyboard=buttons)


async def format_product_select(
    products: List[Dict[str, Any]],
    query: str,
    page: int = 0
) -> Tuple[str, InlineKeyboardMarkup]:
    """
    –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –≤—ã–±–æ—Ä–∞ —Ç–æ–≤–∞—Ä–∞ –∏–∑ —Å–ø–∏—Å–∫–∞ —Å –ø–∞–≥–∏–Ω–∞—Ü–∏–µ–π.
    
    :param products: —Å–ø–∏—Å–æ–∫ —Ç–æ–≤–∞—Ä–æ–≤
    :param query: –ø–æ–∏—Å–∫–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å
    :param page: –Ω–æ–º–µ—Ä —Å—Ç—Ä–∞–Ω–∏—Ü—ã
    :return: —Ç–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è –∏ –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞
    """
    # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –ø–∞–≥–∏–Ω–∞—Ü–∏—é
    total_pages = math.ceil(len(products) / PAGE_SIZE)
    page = max(0, min(page, total_pages - 1))
    
    # –ü–æ–ª—É—á–∞–µ–º —Ç–æ–≤–∞—Ä—ã –¥–ª—è —Ç–µ–∫—É—â–µ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã
    start_idx = page * PAGE_SIZE
    end_idx = min(start_idx + PAGE_SIZE, len(products))
    current_products = products[start_idx:end_idx]
    
    # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
    message = f"üîç <b>–í—ã–±–æ—Ä —Ç–æ–≤–∞—Ä–∞ –¥–ª—è '{query}'</b>\n"
    
    if total_pages > 1:
        message += f"<i>–°—Ç—Ä–∞–Ω–∏—Ü–∞ {page + 1} –∏–∑ {total_pages}</i>\n"
    
    message += "\n<b>–í—ã–±–µ—Ä–∏—Ç–µ —Ç–æ–≤–∞—Ä –∏–∑ —Å–ø–∏—Å–∫–∞:</b>\n\n"
    
    for i, product in enumerate(current_products, start=1):
        name = product.get("name", "Unknown")
        unit = product.get("unit", "")
        confidence = product.get("confidence", 0) * 100
        
        message += f"{i}. <b>{name}</b> ({unit})"
        
        if confidence < 100:
            message += f" <i>{confidence:.0f}% —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ</i>"
        
        message += "\n"
    
    if not current_products:
        message += "<i>–¢–æ–≤–∞—Ä—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∏–∑–º–µ–Ω–∏—Ç—å –∑–∞–ø—Ä–æ—Å –∏–ª–∏ —Å–æ–∑–¥–∞–π—Ç–µ –Ω–æ–≤—ã–π —Ç–æ–≤–∞—Ä.</i>"
    
    # –°–æ–∑–¥–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É
    buttons = []
    
    # –ö–Ω–æ–ø–∫–∏ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ç–æ–≤–∞—Ä–∞
    for product in current_products:
        product_id = product.get("id")
        name = product.get("name", "")
        unit = product.get("unit", "")
        
        if len(name) > 25:
            name = name[:22] + "..."
        
        display_text = f"{name} ({unit})"
        buttons.append([
            InlineKeyboardButton(text=display_text, callback_data=f"{CB_PRODUCT_PREFIX}{product_id}")
        ])
    
    # –ö–Ω–æ–ø–∫–∏ –ø–∞–≥–∏–Ω–∞—Ü–∏–∏
    pagination_row = []
    
    if page > 0:
        pagination_row.append(
            InlineKeyboardButton(text="‚óÄÔ∏è –ü—Ä–µ–¥", callback_data=f"{CB_PAGE_PREFIX}{page-1}")
        )
    
    if page < total_pages - 1:
        pagination_row.append(
            InlineKeyboardButton(text="–°–ª–µ–¥ ‚ñ∂Ô∏è", callback_data=f"{CB_PAGE_PREFIX}{page+1}")
        )
    
    if pagination_row:
        buttons.append(pagination_row)
    
    # –ö–Ω–æ–ø–∫–∏ –ø–æ–∏—Å–∫–∞ –∏ —Å–æ–∑–¥–∞–Ω–∏—è
    buttons.append([
        InlineKeyboardButton(text="üîç –ü–æ–∏—Å–∫", callback_data=CB_SEARCH),
        InlineKeyboardButton(text="‚ûï –ù–æ–≤—ã–π —Ç–æ–≤–∞—Ä", callback_data=CB_ADD_NEW)
    ])
    
    # –ö–Ω–æ–ø–∫–∞ "–ù–∞–∑–∞–¥"
    buttons.append([
        InlineKeyboardButton(text="‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data=CB_BACK)
    ])
    
    return message, InlineKeyboardMarkup(inline_keyboard=buttons)


async def format_final_preview(
    invoice_data: Dict[str, Any],
    original_issues: List[Dict[str, Any]],
    fixed_issues: Dict[int, Dict[str, Any]]
) -> Tuple[str, InlineKeyboardMarkup]:
    """
    –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç —Ñ–∏–Ω–∞–ª—å–Ω—ã–π –ø—Ä–æ—Å–º–æ—Ç—Ä –Ω–∞–∫–ª–∞–¥–Ω–æ–π –ø–µ—Ä–µ–¥ –æ—Ç–ø—Ä–∞–≤–∫–æ–π.
    
    :param invoice_data: –¥–∞–Ω–Ω—ã–µ –Ω–∞–∫–ª–∞–¥–Ω–æ–π
    :param original_issues: –∏—Å—Ö–æ–¥–Ω—ã–π —Å–ø–∏—Å–æ–∫ –ø—Ä–æ–±–ª–µ–º
    :param fixed_issues: –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã—Ö –ø—Ä–æ–±–ª–µ–º–∞—Ö
    :return: —Ç–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è –∏ –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞
    """
    # –ü–æ–ª—É—á–∞–µ–º –æ—Å–Ω–æ–≤–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –Ω–∞–∫–ª–∞–¥–Ω–æ–π
    supplier = invoice_data.get("supplier", "Unknown")
    date = invoice_data.get("date", "Unknown")
    invoice_number = invoice_data.get("number", "")
    
    # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏–∏
    positions = invoice_data.get("positions", [])
    active_positions = [p for p in positions if not p.get("deleted", False)]
    
    fixed_count = len(fixed_issues)
    original_issues_count = len(original_issues)
    remaining_issues = original_issues_count - fixed_count
    
    # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
    message = f"‚úÖ <b>–ù–∞–∫–ª–∞–¥–Ω–∞—è –≥–æ—Ç–æ–≤–∞ –∫ –æ—Ç–ø—Ä–∞–≤–∫–µ</b>\n\n"
    message += f"üè∑Ô∏è <b>–ü–æ—Å—Ç–∞–≤—â–∏–∫:</b> {supplier}\n"
    message += f"üìÖ <b>–î–∞—Ç–∞:</b> {date}{f' ‚Ññ{invoice_number}' if invoice_number else ''}\n\n"
    
    # –î–æ–±–∞–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
    message += f"<b>–í—Å–µ–≥–æ –ø–æ–∑–∏—Ü–∏–π:</b> {len(active_positions)}\n"
    
    if fixed_count > 0:
        message += f"‚úÖ <b>–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ –ø—Ä–æ–±–ª–µ–º:</b> {fixed_count}\n"
    
    if remaining_issues > 0:
        message += f"‚ö†Ô∏è <b>–û—Å—Ç–∞–ª–æ—Å—å –ø—Ä–æ–±–ª–µ–º:</b> {remaining_issues}\n"
    else:
        message += "‚úÖ <b>–í—Å–µ –ø—Ä–æ–±–ª–µ–º—ã —Ä–µ—à–µ–Ω—ã!</b>\n"
    
    # –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é
    if remaining_issues > 0:
        message += "\n‚ö†Ô∏è <i>–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: –ù–µ–∫–æ—Ç–æ—Ä—ã–µ –ø—Ä–æ–±–ª–µ–º—ã –æ—Å—Ç–∞–ª–∏—Å—å –Ω–µ—Ä–∞–∑—Ä–µ—à–µ–Ω–Ω—ã–º–∏, –Ω–æ –≤—ã –≤—Å–µ —Ä–∞–≤–Ω–æ –º–æ–∂–µ—Ç–µ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å.</i>"
    
    message += "\n\n–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –Ω–∞–∫–ª–∞–¥–Ω–æ–π –≤ Syrve."
    
    # –°–æ–∑–¥–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É
    buttons = [
        [InlineKeyboardButton(text="‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –∏ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å", callback_data=CB_CONFIRM)],
        [InlineKeyboardButton(text="‚óÄÔ∏è –í–µ—Ä–Ω—É—Ç—å—Å—è –∫ –ø—Ä–∞–≤–∫–∞–º", callback_data=CB_BACK)]
    ]
    
    return message, InlineKeyboardMarkup(inline_keyboard=buttons)


def format_field_prompt(field: str, current_value: str) -> str:
    """
    Format a prompt for editing a specific field.
    
    Args:
        field: The field name being edited
        current_value: The current value of the field
        
    Returns:
        HTML formatted prompt text
    """
    field_labels = {
        "name": "–Ω–∞–∑–≤–∞–Ω–∏—è",
        "qty": "–∫–æ–ª–∏—á–µ—Å—Ç–≤–∞",
        "unit": "–µ–¥–∏–Ω–∏—Ü—ã –∏–∑–º–µ—Ä–µ–Ω–∏—è",
        "price": "—Ü–µ–Ω—ã"
    }
    
    field_label = field_labels.get(field, field)
    
    message = f"<b>–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ {field_label}:</b>\n\n"
    message += f"–¢–µ–∫—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {current_value}\n\n"
    
    field_hints = {
        "name": "–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞ (–º–∞–∫—Å–∏–º—É–º 100 —Å–∏–º–≤–æ–ª–æ–≤)",
        "qty": "–í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ–≤–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ (–Ω–∞–ø—Ä–∏–º–µ—Ä, 5 –∏–ª–∏ 2.5)",
        "unit": "–í–≤–µ–¥–∏—Ç–µ –µ–¥–∏–Ω–∏—Ü—É –∏–∑–º–µ—Ä–µ–Ω–∏—è (–Ω–∞–ø—Ä–∏–º–µ—Ä, –∫–≥, –ª, —à—Ç)",
        "price": "–í–≤–µ–¥–∏—Ç–µ —Ü–µ–Ω—É (—Ç–æ–ª—å–∫–æ —á–∏—Å–ª–∞)"
    }
    
    if field in field_hints:
        message += f"<i>{field_hints[field]}</i>"
        
    return message

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
@router.callback_query(Text(CB_BACK))
async def cb_back(c: CallbackQuery, state: FSMContext):
    """
    –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ "–ù–∞–∑–∞–¥" - –≤–æ–∑–≤—Ä–∞—Ç –∫ –ø—Ä–µ–¥—ã–¥—É—â–µ–º—É —Å–æ—Å—Ç–æ—è–Ω–∏—é.
    """
    current_state = await state.get_state()
    data = await state.get_data()
    
    if current_state == InvoiceEditStates.issue_edit.state:
        # –í–æ–∑–≤—Ä–∞—Ç –∫ —Å–ø–∏—Å–∫—É –ø—Ä–æ–±–ª–µ–º
        await state.set_state(InvoiceEditStates.issue_list)
        
        issues = data.get("current_issues", [])
        
        message, keyboard = await format_issues_list(
            {"issues": issues}, 
            page=data.get("current_page", 0)
        )
        
        try:
            await c.message.edit_text(message, reply_markup=keyboard, parse_mode="HTML")
        except Exception as e:
            logger.error("Failed to edit message", error=str(e))
            await c.message.answer(message, reply_markup=keyboard, parse_mode="HTML")
    
    elif current_state == InvoiceEditStates.product_select.state:
        # –í–æ–∑–≤—Ä–∞—Ç –∫ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—é –ø–æ–∑–∏—Ü–∏–∏
        await state.set_state(InvoiceEditStates.issue_edit)
        
        selected_issue = data.get("selected_issue", {})
        
        message, keyboard = await format_issue_edit(selected_issue)
        
        try:
            await c.message.edit_text(message, reply_markup=keyboard, parse_mode="HTML")
        except Exception as e:
            logger.error("Failed to edit message", error=str(e))
            await c.message.answer(message, reply_markup=keyboard, parse_mode="HTML")
    
    elif current_state == InvoiceEditStates.field_input.state:
        # –í–æ–∑–≤—Ä–∞—Ç –∫ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—é –ø–æ–∑–∏—Ü–∏–∏
        await state.set_state(InvoiceEditStates.issue_edit)
        
        selected_issue = data.get("selected_issue", {})
        
        message, keyboard = await format_issue_edit(selected_issue)
        
        try:
            await c.message.edit_text(message, reply_markup=keyboard, parse_mode="HTML")
        except Exception as e:
            logger.error("Failed to edit message", error=str(e))
            await c.message.answer(message, reply_markup=keyboard, parse_mode="HTML")
    
    elif current_state == InvoiceEditStates.confirm.state:
        # –í–æ–∑–≤—Ä–∞—Ç –∫ —Å–ø–∏—Å–∫—É –ø—Ä–æ–±–ª–µ–º
        await state.set_state(InvoiceEditStates.issue_list)
        
        issues = data.get("current_issues", [])
        
        # –ï—Å–ª–∏ —Å–ø–∏—Å–æ–∫ –ø—É—Å—Ç, –±–µ—Ä–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π —Å–ø–∏—Å–æ–∫ –ø—Ä–æ–±–ª–µ–º
        if not issues:
            issues = data.get("issues", [])
            await state.update_data(current_issues=issues)
        
        message, keyboard = await format_issues_list(
            {"issues": issues}, 
            page=data.get("current_page", 0)
        )
        
        try:
            await c.message.edit_text(message, reply_markup=keyboard, parse_mode="HTML")
        except Exception as e:
            logger.error("Failed to edit message", error=str(e))
            await c.message.answer(message, reply_markup=keyboard, parse_mode="HTML")
    
    await c.answer()


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –≤—ã–±–æ—Ä–∞ –ø–æ–∑–∏—Ü–∏–∏ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
@router.callback_query(Text(["inv_edit", CB_REVIEW]))
async def cb_start_review(c: CallbackQuery, state: FSMContext):
    """
    –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–∞—á–∞–ª–∞ –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –ø—Ä–æ–±–ª–µ–º–Ω—ã—Ö –ø–æ–∑–∏—Ü–∏–π.
    
    –ê–∫—Ç–∏–≤–∏—Ä—É–µ—Ç—Å—è –ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ –Ω–∞ –∫–Ω–æ–ø–∫—É "–ò—Å–ø—Ä–∞–≤–∏—Ç—å" –≤ —Å–≤–æ–¥–∫–µ –Ω–∞–∫–ª–∞–¥–Ω–æ–π.
    """
    # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ —Å–æ—Å—Ç–æ—è–Ω–∏—è
    data = await state.get_data()
    invoice = data.get("invoice", {})
    issues = data.get("issues", [])
    
    if not issues:
        await c.message.answer("‚ùå –ù–µ—Ç –ø—Ä–æ–±–ª–µ–º–Ω—ã—Ö –ø–æ–∑–∏—Ü–∏–π –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞.")
        await c.answer()
        return
    
    # –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    await state.update_data(current_issues=issues, fixed_issues={})
    await state.set_state(InvoiceEditStates.issue_list)
    
    # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å–æ —Å–ø–∏—Å–∫–æ–º –ø—Ä–æ–±–ª–µ–º
    message, keyboard = await format_issues_list({"issues": issues}, page=0)
    
    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
    try:
        await c.message.edit_text(message, reply_markup=keyboard, parse_mode="HTML")
    except Exception as e:
        logger.error("Failed to edit message", error=str(e))
        await c.message.answer(message, reply_markup=keyboard, parse_mode="HTML")
    
    await c.answer()


@router.callback_query(lambda c: c.data and c.data.startswith(CB_ISSUE_PREFIX), InvoiceEditStates.issue_list)
async def cb_select_issue(c: CallbackQuery, state: FSMContext):
    """
    –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤—ã–±–æ—Ä–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –ø—Ä–æ–±–ª–µ–º–Ω–æ–π –ø–æ–∑–∏—Ü–∏–∏ –∏–∑ —Å–ø–∏—Å–∫–∞.
    """
    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∏–Ω–¥–µ–∫—Å –ø–æ–∑–∏—Ü–∏–∏ –∏–∑ callback_data
    try:
        position_index = int(c.data[len(CB_ISSUE_PREFIX):]) - 1
    except ValueError:
        await c.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –ø–æ–∑–∏—Ü–∏–∏.")
        return
    
    # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ —Å–æ—Å—Ç–æ—è–Ω–∏—è
    data = await state.get_data()
    current_issues = data.get("current_issues", [])
    
    # –ù–∞—Ö–æ–¥–∏–º –ø—Ä–æ–±–ª–µ–º–Ω—É—é –ø–æ–∑–∏—Ü–∏—é
    selected_issue = None
    for issue in current_issues:
        issue_index = issue.get("index", 0) - 1  # –ò–Ω–¥–µ–∫—Å –≤ –Ω–∞–∫–ª–∞–¥–Ω–æ–π (0-based)
        if issue_index == position_index:
            selected_issue = issue
            break
    
    if not selected_issue:
        await c.answer("‚ùå –ü–æ–∑–∏—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")
        return
    
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤—ã–±—Ä–∞–Ω–Ω—É—é –ø–æ–∑–∏—Ü–∏—é –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏
    await state.update_data(
        selected_issue=selected_issue,
        selected_issue_idx=current_issues.index(selected_issue)
    )
    await state.set_state(InvoiceEditStates.issue_edit)
    
    # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
    message, keyboard = await format_issue_edit(selected_issue)
    
    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
    try:
        await c.message.edit_text(message, reply_markup=keyboard, parse_mode="HTML")
    except Exception as e:
        logger.error("Failed to edit message", error=str(e))
        await c.message.answer(message, reply_markup=keyboard, parse_mode="HTML")
    
    await c.answer()


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –ø–∞–≥–∏–Ω–∞—Ü–∏–∏ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
@router.callback_query(lambda c: c.data and c.data.startswith(CB_PAGE_PREFIX))
async def cb_change_page(c: CallbackQuery, state: FSMContext):
    """
    –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –ø–∞–≥–∏–Ω–∞—Ü–∏–∏ –¥–ª—è —Å–ø–∏—Å–∫–æ–≤ –ø–æ–∑–∏—Ü–∏–π –∏ —Ç–æ–≤–∞—Ä–æ–≤.
    """
    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–æ–º–µ—Ä —Å—Ç—Ä–∞–Ω–∏—Ü—ã
    page = int(c.data[len(CB_PAGE_PREFIX):])
    
    # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    current_state = await state.get_state()
    data = await state.get_data()
    
    if current_state == InvoiceEditStates.issue_list.state:
        # –ü–∞–≥–∏–Ω–∞—Ü–∏—è –≤ —Å–ø–∏—Å–∫–µ –ø—Ä–æ–±–ª–µ–º–Ω—ã—Ö –ø–æ–∑–∏—Ü–∏–π
        current_issues = data.get("current_issues", [])
        await state.update_data(current_page=page)
        
        message, keyboard = await format_issues_list({"issues": current_issues}, page=page)
    
    elif current_state == InvoiceEditStates.product_select.state:
        # –ü–∞–≥–∏–Ω–∞—Ü–∏—è –≤ —Å–ø–∏—Å–∫–µ —Ç–æ–≤–∞—Ä–æ–≤
        products = data.get("products", [])
        query = data.get("search_query", "")
        await state.update_data(current_page=page)
        
        message, keyboard = await format_product_select(products, query, page=page)
    
    else:
        await c.answer("‚ùå –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –ø–∞–≥–∏–Ω–∞—Ü–∏–∏.")
        return
    
    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
    try:
        await c.message.edit_text(message, reply_markup=keyboard, parse_mode="HTML")
    except Exception as e:
        logger.error("Failed to edit message", error=str(e))
        await c.message.answer(message, reply_markup=keyboard, parse_mode="HTML")
    
    await c.answer()


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤—ã–±–æ—Ä–∞ –ø—Ä–æ–¥—É–∫—Ç–∞ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
@router.callback_query(lambda c: c.data and c.data.startswith(CB_PRODUCT_PREFIX), InvoiceEditStates.product_select)
async def cb_select_product(c: CallbackQuery, state: FSMContext):
    """
    –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤—ã–±–æ—Ä–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –ø—Ä–æ–¥—É–∫—Ç–∞ –∏–∑ —Å–ø–∏—Å–∫–∞.
    """
    # –ü–æ–ª—É—á–∞–µ–º ID –ø—Ä–æ–¥—É–∫—Ç–∞ –∏–∑ callback_data
    product_id = int(c.data[len(CB_PRODUCT_PREFIX):])
    
    # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ —Å–æ—Å—Ç–æ—è–Ω–∏—è
    data = await state.get_data()
    selected_issue = data.get("selected_issue", {})
    invoice_data = data.get("invoice", {})
    positions = invoice_data.get("positions", [])
    
    # –ù–∞—Ö–æ–¥–∏–º –∏–Ω–¥–µ–∫—Å—ã
    issue_idx = data.get("selected_issue_idx", 0)
    issues = data.get("current_issues", [])
    position_idx = selected_issue.get("index", 0) - 1
    
    if 0 <= position_idx < len(positions):
        # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≤—ã–±—Ä–∞–Ω–Ω–æ–º –ø—Ä–æ–¥—É–∫—Ç–µ
        products = data.get("products", [])
        selected_product = None
        
        for product in products:
            if product.get("id") == product_id:
                selected_product = product
                break
        
        if not selected_product:
            await c.answer("‚ùå –í—ã–±—Ä–∞–Ω–Ω—ã–π –ø—Ä–æ–¥—É–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω.")
            return
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏
        position = positions[position_idx]
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Ç–∞—Ä—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
        old_name = position.get("name", "")
        
        # –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ
        position["match_id"] = product_id
        position["confidence"] = 1.0  # –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º –≤—Ä—É—á–Ω—É—é
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö - –¥–æ–±–∞–≤–ª—è–µ–º –≤ —Ç–∞–±–ª–∏—Ü—É —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–π
        try:
            async with SessionLocal() as session:
                success = await save_product_match(
                    session, 
                    old_name,  # –ò—Å—Ö–æ–¥–Ω–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –∏–∑ –Ω–∞–∫–ª–∞–¥–Ω–æ–π
                    product_id  # ID –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –ø—Ä–æ–¥—É–∫—Ç–∞
                )
                
                if success:
                    logger.info("Product match saved to lookup table", 
                               name=old_name, product_id=product_id)
                else:
                    logger.warning("Failed to save product match", 
                                  name=old_name, product_id=product_id)
        except Exception as e:
            logger.error("Error saving product match", error=str(e))
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –Ω–∞–∫–ª–∞–¥–Ω–æ–π –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏
        invoice_data["positions"] = positions
        await state.update_data(invoice=invoice_data)
        
        # –î–æ–±–∞–≤–ª—è–µ–º –≤ —Å–ø–∏—Å–æ–∫ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã—Ö –ø–æ–∑–∏—Ü–∏–π
        fixed_issues = data.get("fixed_issues", {}) or {}
        fixed_issues[position_idx] = {
            "action": "match_product",
            "product_id": product_id,
            "product_name": selected_product.get("name")
        }
        await state.update_data(fixed_issues=fixed_issues)
        
        # –õ–æ–≥–∏—Ä—É–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏–µ
        try:
            invoice_id = invoice_data.get("id", 0)
            user_id = c.from_user.id if c.from_user else 0
            
            await log_change(
                invoice_id=invoice_id,
                row_idx=position_idx,
                user_id=user_id,
                field="match_id",
                old=None,
                new=product_id
            )
        except Exception as e:
            logger.error("Failed to log product match", error=str(e))
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç—å –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ –µ–¥–∏–Ω–∏—Ü
        position_unit = normalize_unit(position.get("unit", ""))
        product_unit = normalize_unit(selected_product.get("unit", ""))
        
        if position_unit and product_unit and position_unit != product_unit:
            # –ï—Å—Ç—å –Ω–µ—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ –µ–¥–∏–Ω–∏—Ü, –ø—Ä–µ–¥–ª–∞–≥–∞–µ–º –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—é
            await state.update_data(
                product_match_unit_mismatch=True,
                from_unit=position_unit,
                to_unit=product_unit,
                product_name=selected_product.get("name")
            )
            
            # –°–æ–∑–¥–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –¥–ª—è –≤—ã–±–æ—Ä–∞ –¥–µ–π—Å—Ç–≤–∏—è
            keyboard = InlineKeyboardMarkup(inline_keyboard=[
                [
                    InlineKeyboardButton(text="üîÑ –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –µ–¥–∏–Ω–∏—Ü—ã", 
                                        callback_data=f"{CB_CONVERT_PREFIX}auto"),
                    InlineKeyboardButton(text="‚úÖ –û—Å—Ç–∞–≤–∏—Ç—å –∫–∞–∫ –µ—Å—Ç—å", 
                                        callback_data=f"{CB_CONVERT_PREFIX}skip")
                ]
            ])
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
            await c.message.answer(
                f"‚ö†Ô∏è <b>–û–±–Ω–∞—Ä—É–∂–µ–Ω–æ –Ω–µ—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ –µ–¥–∏–Ω–∏—Ü –∏–∑–º–µ—Ä–µ–Ω–∏—è</b>\n\n"
                f"–¢–æ–≤–∞—Ä <b>{selected_product.get('name')}</b> –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö –∏–º–µ–µ—Ç "
                f"–µ–¥–∏–Ω–∏—Ü—É –∏–∑–º–µ—Ä–µ–Ω–∏—è <b>{product_unit}</b>, –Ω–æ –≤ –Ω–∞–∫–ª–∞–¥–Ω–æ–π —É–∫–∞–∑–∞–Ω–æ <b>{position_unit}</b>.\n\n"
                f"–•–æ—Ç–∏—Ç–µ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –µ–¥–∏–Ω–∏—Ü—ã?",
                reply_markup=keyboard,
                parse_mode="HTML"
            )
            await c.answer()
            return
        
        # –û–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫ –ø—Ä–æ–±–ª–µ–º (—É–¥–∞–ª—è–µ–º –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—É—é)
        current_issues = [issue for i, issue in enumerate(issues) if i != issue_idx]
        await state.update_data(current_issues=current_issues)
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å–ª–µ–¥—É—é—â–∏–π —à–∞–≥
        if not current_issues:
            # –ï—Å–ª–∏ –ø—Ä–æ–±–ª–µ–º –±–æ–ª—å—à–µ –Ω–µ—Ç, –ø–µ—Ä–µ—Ö–æ–¥–∏–º –∫ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—é
            await state.set_state(InvoiceEditStates.confirm)
            
            message, keyboard = await format_final_preview(
                invoice_data, 
                data.get("issues", []), 
                fixed_issues
            )
        else:
            # –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –∫ —Å–ø–∏—Å–∫—É –ø—Ä–æ–±–ª–µ–º
            await state.set_state(InvoiceEditStates.issue_list)
            
            message, keyboard = await format_issues_list(
                {"issues": current_issues}, 
                page=data.get("current_page", 0)
            )
        
        # –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–∏
        message = (
            f"‚úÖ –¢–æ–≤–∞—Ä —É—Å–ø–µ—à–Ω–æ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω —Å <b>{selected_product.get('name')}</b>.\n\n"
            + message
        )
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
        try:
            await c.message.edit_text(message, reply_markup=keyboard, parse_mode="HTML")
        except Exception as e:
            logger.error("Failed to edit message", error=str(e))
            await c.message.answer(message, reply_markup=keyboard, parse_mode="HTML")
    else:
        await c.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø–æ–∑–∏—Ü–∏–∏.")
    
    await c.answer()

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–µ–π—Å—Ç–≤–∏–π —Å –ø–æ–∑–∏—Ü–∏–µ–π ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
@router.callback_query(lambda c: c.data and c.data.startswith(CB_ACTION_PREFIX), InvoiceEditStates.issue_edit)
async def cb_action_with_item(c: CallbackQuery, state: FSMContext):
    """
    –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤—ã–±–æ—Ä–∞ –¥–µ–π—Å—Ç–≤–∏—è —Å –ø—Ä–æ–±–ª–µ–º–Ω–æ–π –ø–æ–∑–∏—Ü–∏–µ–π.
    """
    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –¥–µ–π—Å—Ç–≤–∏–µ
    action = c.data[len(CB_ACTION_PREFIX):]
    
    # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ —Å–æ—Å—Ç–æ—è–Ω–∏—è
    data = await state.get_data()
    selected_issue = data.get("selected_issue", {})
    original = selected_issue.get("original", {})
    
    # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ä–∞–∑–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è
    if action == "name":
        # –ü–µ—Ä–µ—Ö–æ–¥ –∫ –≤—ã–±–æ—Ä—É —Ç–æ–≤–∞—Ä–∞
        await state.set_state(InvoiceEditStates.product_select)
        
        # –ü–æ–ª—É—á–∞–µ–º –Ω–∞–∑–≤–∞–Ω–∏–µ –¥–ª—è –ø–æ–∏—Å–∫–∞
        name_query = original.get("name", "")[:5]  # –ü–µ—Ä–≤—ã–µ 5 —Å–∏–º–≤–æ–ª–æ–≤ –¥–ª—è –ø–æ–∏—Å–∫–∞
        await state.update_data(search_query=name_query)
        
        # –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ —Ç–æ–≤–∞—Ä–æ–≤ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é
        async with SessionLocal() as session:
            products = await get_products_by_name(session, name_query)
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–ø–∏—Å–æ–∫ —Ç–æ–≤–∞—Ä–æ–≤ –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏
        await state.update_data(products=products, current_page=0)
        
        # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –≤—ã–±–æ—Ä–∞ —Ç–æ–≤–∞—Ä–∞
        message, keyboard = await format_product_select(products, name_query, page=0)
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
        try:
            await c.message.edit_text(message, reply_markup=keyboard, parse_mode="HTML")
        except Exception as e:
            logger.error("Failed to edit message", error=str(e))
            await c.message.answer(message, reply_markup=keyboard, parse_mode="HTML")
    
    elif action == "edit_name":
        # –ü–µ—Ä–µ—Ö–æ–¥ –∫ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—é –∏–º–µ–Ω–∏
        await state.set_state(InvoiceEditStates.field_input)
        await state.update_data(field="name")
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∑–∞–ø—Ä–æ—Å–æ–º
        msg = format_field_prompt("name", original.get("name", ""))
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å ForceReply –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –æ—Ç–≤–µ—Ç–∞
        await c.message.edit_text(msg, parse_mode="HTML")
        await c.message.answer("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ:", reply_markup=ForceReply())
    
    elif action == "qty":
        # –ü–µ—Ä–µ—Ö–æ–¥ –∫ –≤–≤–æ–¥—É –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞
        await state.set_state(InvoiceEditStates.field_input)
        await state.update_data(field="quantity")
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∑–∞–ø—Ä–æ—Å–æ–º
        msg = format_field_prompt("qty", f"{original.get('quantity', 0)} {original.get('unit', '')}")
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å ForceReply –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –æ—Ç–≤–µ—Ç–∞
        await c.message.edit_text(msg, parse_mode="HTML")
        await c.message.answer("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ:", reply_markup=ForceReply())
    
    elif action == "unit":
        # –ü–µ—Ä–µ—Ö–æ–¥ –∫ –≤—ã–±–æ—Ä—É –µ–¥–∏–Ω–∏—Ü—ã –∏–∑–º–µ—Ä–µ–Ω–∏—è
        await state.set_state(InvoiceEditStates.field_input)
        await state.update_data(field="unit")
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∑–∞–ø—Ä–æ—Å–æ–º
        msg = format_field_prompt("unit", original.get("unit", ""))
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å ForceReply –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –æ—Ç–≤–µ—Ç–∞
        await c.message.edit_text(msg, parse_mode="HTML")
        await c.message.answer("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—É—é –µ–¥–∏–Ω–∏—Ü—É –∏–∑–º–µ—Ä–µ–Ω–∏—è:", reply_markup=ForceReply())
    
    elif action == "delete":
        # –£–¥–∞–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏
        invoice_data = data.get("invoice", {})
        positions = invoice_data.get("positions", [])
        
        issue_idx = data.get("selected_issue_idx", 0)
        issues = data.get("current_issues", [])
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∏–Ω–¥–µ–∫—Å –ø–æ–∑–∏—Ü–∏–∏ –≤ –æ–±—â–µ–º —Å–ø–∏—Å–∫–µ
        position_idx = selected_issue.get("index", 0) - 1
        
        if 0 <= position_idx < len(positions):
            # –ü–æ–º–µ—á–∞–µ–º –ø–æ–∑–∏—Ü–∏—é –∫–∞–∫ —É–¥–∞–ª–µ–Ω–Ω—É—é
            positions[position_idx]["deleted"] = True
            
            # –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏
            invoice_data["positions"] = positions
            await state.update_data(invoice=invoice_data)
            
            # –î–æ–±–∞–≤–ª—è–µ–º –≤ —Å–ø–∏—Å–æ–∫ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã—Ö –ø–æ–∑–∏—Ü–∏–π
            fixed_issues = data.get("fixed_issues", {}) or {}
            fixed_issues[position_idx] = {"action": "delete"}
            await state.update_data(fixed_issues=fixed_issues)
            
            # –õ–æ–≥–∏—Ä—É–µ–º —É–¥–∞–ª–µ–Ω–∏–µ
            try:
                invoice_id = invoice_data.get("id", 0)
                user_id = c.from_user.id if c.from_user else 0
                item_name = original.get("name", "")
                
                await log_delete(
                    invoice_id=invoice_id,
                    row_idx=position_idx,
                    user_id=user_id,
                    item_name=item_name
                )
            except Exception as e:
                logger.error("Failed to log delete action", error=str(e))
            
            # –û–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫ –ø—Ä–æ–±–ª–µ–º (—É–¥–∞–ª—è–µ–º —Ä–µ—à–µ–Ω–Ω—É—é)
            current_issues = [issue for i, issue in enumerate(issues) if i != issue_idx]
            await state.update_data(current_issues=current_issues)
            
            # –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –∫ —Å–ø–∏—Å–∫—É –ø—Ä–æ–±–ª–µ–º –∏–ª–∏ –∫ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—é
            if not current_issues:
                # –ï—Å–ª–∏ –ø—Ä–æ–±–ª–µ–º –±–æ–ª—å—à–µ –Ω–µ—Ç, –ø–µ—Ä–µ—Ö–æ–¥–∏–º –∫ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—é
                await state.set_state(InvoiceEditStates.confirm)
                
                message, keyboard = await format_final_preview(
                    invoice_data, 
                    data.get("issues", []), 
                    fixed_issues
                )
            else:
                # –ï—Å–ª–∏ –µ—Å—Ç—å –µ—â–µ –ø—Ä–æ–±–ª–µ–º—ã, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –∫ —Å–ø–∏—Å–∫—É
                await state.set_state(InvoiceEditStates.issue_list)
                
                message, keyboard = await format_issues_list(
                    {"issues": current_issues}, 
                    page=data.get("current_page", 0)
                )
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
            try:
                await c.message.edit_text(message, reply_markup=keyboard, parse_mode="HTML")
            except Exception as e:
                logger.error("Failed to edit message", error=str(e))
                await c.message.answer(message, reply_markup=keyboard, parse_mode="HTML")
        else:
            await c.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –ø–æ–∑–∏—Ü–∏–∏.")
    
    elif action == "add_new":
        # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–æ–≤–æ–≥–æ —Ç–æ–≤–∞—Ä–∞
        invoice_data = data.get("invoice", {})
        position_idx = selected_issue.get("index", 0) - 1
        
        # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏
        if "positions" in invoice_data and 0 <= position_idx < len(invoice_data["positions"]):
            # –û—Ç–º–µ—á–∞–µ–º, —á—Ç–æ —ç—Ç–∞ –ø–æ–∑–∏—Ü–∏—è –±—É–¥–µ—Ç –¥–æ–±–∞–≤–ª–µ–Ω–∞ –∫–∞–∫ –Ω–æ–≤—ã–π —Ç–æ–≤–∞—Ä
            fixed_issues = data.get("fixed_issues", {}) or {}
            fixed_issues[position_idx] = {"action": "new_product"}
            await state.update_data(fixed_issues=fixed_issues)
            
            # –õ–æ–≥–∏—Ä—É–µ–º —Å–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ —Ç–æ–≤–∞—Ä–∞
            try:
                invoice_id = invoice_data.get("id", 0)
                user_id = c.from_user.id if c.from_user else 0
                item_name = original.get("name", "")
                
                await log_save_new(
                    invoice_id=invoice_id,
                    row_idx=position_idx,
                    user_id=user_id,
                    item_name=item_name
                )
            except Exception as e:
                logger.error("Failed to log save_new action", error=str(e))
            
            # –û–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫ –ø—Ä–æ–±–ª–µ–º (—É–¥–∞–ª—è–µ–º —Ä–µ—à–µ–Ω–Ω—É—é)
            issues = data.get("current_issues", [])
            issue_idx = data.get("selected_issue_idx", 0)
            current_issues = [issue for i, issue in enumerate(issues) if i != issue_idx]
            await state.update_data(current_issues=current_issues)
            
            # –í–µ—Ä–Ω—É—Ç—å—Å—è –∫ —Å–ø–∏—Å–∫—É –ø—Ä–æ–±–ª–µ–º –∏–ª–∏ –∫ —Ñ–∏–Ω–∞–ª—å–Ω–æ–º—É –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—é
            if not current_issues:
                await state.set_state(InvoiceEditStates.confirm)
                
                message, keyboard = await format_final_preview(
                    invoice_data,
                    data.get("issues", []),
                    fixed_issues,
                )
            else:
                await state.set_state(InvoiceEditStates.issue_list)
                
                message, keyboard = await format_issues_list(
                    {"issues": current_issues},
                    page=data.get("current_page", 0),
                )
            
            # –°–æ–æ–±—â–µ–Ω–∏–µ –æ–± —É—Å–ø–µ—à–Ω–æ–º –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ —Ç–æ–≤–∞—Ä–∞
            message = (
                f"‚úÖ –¢–æ–≤–∞—Ä <b>{original.get('name', '')}</b> —Å–æ—Ö—Ä–∞–Ω—ë–Ω –∫–∞–∫ –Ω–æ–≤—ã–π!\n\n"
                + message
            )
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
            try:
                await c.message.edit_text(
                    message,
                    reply_markup=keyboard,
                    parse_mode="HTML",
                )
            except Exception as e:
                logger.error("Failed to edit message", error=str(e))
                await c.message.answer(
                    message,
                    reply_markup=keyboard,
                    parse_mode="HTML",
                )
        else:
            await c.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –Ω–æ–≤–æ–≥–æ —Ç–æ–≤–∞—Ä–∞.")
    
    elif action == "convert":
        # –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –µ–¥–∏–Ω–∏—Ü –∏–∑–º–µ—Ä–µ–Ω–∏—è
        product = selected_issue.get("product")
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –ø—Ä–æ–¥—É–∫—Ç–∞ –ø–µ—Ä–µ–¥ –ø–æ–ø—ã—Ç–∫–æ–π –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏
        if not product:
            # –í–º–µ—Å—Ç–æ –ø—Ä–æ—Å—Ç–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è –æ–± –æ—à–∏–±–∫–µ –ø—Ä–µ–¥–ª–∞–≥–∞–µ–º –≤–∞—Ä–∏–∞–Ω—Ç—ã –¥–µ–π—Å—Ç–≤–∏–π
            msg = (
                "‚ùå –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –æ —Ç–æ–≤–∞—Ä–µ –¥–ª—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏.\n\n"
                "–î–ª—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ –µ–¥–∏–Ω–∏—Ü –∏–∑–º–µ—Ä–µ–Ω–∏—è –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —Å–Ω–∞—á–∞–ª–∞ —Å–æ–ø–æ—Å—Ç–∞–≤–∏—Ç—å —Ç–æ–≤–∞—Ä —Å –±–∞–∑–æ–π –¥–∞–Ω–Ω—ã—Ö."
            )
            
            keyboard = InlineKeyboardMarkup(inline_keyboard=[
                [
                    InlineKeyboardButton(text="üîç –ù–∞–π—Ç–∏ –≤ –±–∞–∑–µ", callback_data=f"{CB_ACTION_PREFIX}name"),
                    InlineKeyboardButton(text="‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –Ω–∞–∑–≤–∞–Ω–∏–µ", callback_data=f"{CB_ACTION_PREFIX}edit_name")
                ],
                [
                    InlineKeyboardButton(text="‚ûï –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π", callback_data=f"{CB_ACTION_PREFIX}add_new"),
                    InlineKeyboardButton(text="‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data=CB_BACK)
                ]
            ])
            
            await c.message.edit_text(msg, reply_markup=keyboard, parse_mode="HTML")
            await c.answer()
            return
        
        # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏
        invoice_unit = original.get("unit", "")
        db_unit = product.unit
        
        if not invoice_unit or not db_unit or invoice_unit == db_unit:
            await c.answer("‚ö†Ô∏è –ù–µ—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –≤ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏.")
            return
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å –µ–¥–∏–Ω–∏—Ü
        if not is_compatible_unit(invoice_unit, db_unit):
            msg = f"‚ùå –ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å: –µ–¥–∏–Ω–∏—Ü—ã <b>{invoice_unit}</b> –∏ <b>{db_unit}</b> –Ω–µ—Å–æ–≤–º–µ—Å—Ç–∏–º—ã."
            
            keyboard = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data=CB_BACK)]
            ])
            
            await c.message.edit_text(msg, reply_markup=keyboard, parse_mode="HTML")
            await c.answer()
            return
        
        # –í—ã–ø–æ–ª–Ω—è–µ–º –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—é
        quantity = float(original.get("quantity", 0))
        converted = convert(quantity, invoice_unit, db_unit)

        if converted is None:
            await c.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏.")
            return

        # –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ
        invoice_data = data.get("invoice", {})
        positions = invoice_data.get("positions", [])
        position_idx = selected_issue.get("index", 0) - 1

        if 0 <= position_idx < len(positions):
            # –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é
            positions[position_idx]["quantity"] = converted
            positions[position_idx]["unit"] = db_unit

            # –ü–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º —Å—É–º–º—É, –µ—Å–ª–∏ –µ—Å—Ç—å —Ü–µ–Ω–∞
            if price := positions[position_idx].get("price"):
                try:
                    price_float = float(price)
                    positions[position_idx]["sum"] = converted * price_float
                except (ValueError, TypeError):
                    pass

            # –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏
            invoice_data["positions"] = positions
            await state.update_data(invoice=invoice_data)

            # –î–æ–±–∞–≤–ª—è–µ–º –≤ —Å–ø–∏—Å–æ–∫ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã—Ö –ø–æ–∑–∏—Ü–∏–π
            fixed_issues = data.get("fixed_issues", {}) or {}
            fixed_issues[position_idx] = {
                "action": "convert_unit",
                "from_unit": invoice_unit,
                "to_unit": db_unit,
                "old_quantity": quantity,
                "new_quantity": converted,
            }
            await state.update_data(fixed_issues=fixed_issues)

            # –û–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫ –ø—Ä–æ–±–ª–µ–º (—É–¥–∞–ª—è–µ–º —Ä–µ—à—ë–Ω–Ω—É—é)
            issues = data.get("current_issues", [])
            issue_idx = data.get("selected_issue_idx", 0)
            new_issues = [issue for i, issue in enumerate(issues) if i != issue_idx]
            await state.update_data(current_issues=new_issues)

            # –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –∫ —Å–ø–∏—Å–∫—É –ø—Ä–æ–±–ª–µ–º –∏–ª–∏ –∫ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—é
            if not new_issues:
                await state.set_state(InvoiceEditStates.confirm)
                message, keyboard = await format_final_preview(
                    invoice_data,
                    data.get("issues", []),
                    fixed_issues,
                )
            else:
                await state.set_state(InvoiceEditStates.issue_list)
                message, keyboard = await format_issues_list(
                    {"issues": new_issues},
                    page=data.get("current_page", 0),
                )

            # –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏
            conv_msg = (
                f"‚úÖ –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∞: {quantity} {invoice_unit} ‚Üí "
                f"{converted} {db_unit}\n\n"
                + message
            )
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
            try:
                await c.message.edit_text(conv_msg, reply_markup=keyboard, parse_mode="HTML")
            except Exception as e:
                logger.error("Failed to edit message", error=str(e))
                await c.message.answer(conv_msg, reply_markup=keyboard, parse_mode="HTML")
        else:
            await c.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø–æ–∑–∏—Ü–∏–∏.")
    
    else:
        await c.answer(f"‚ö†Ô∏è –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ: {action}")
    
    # –û—Ç–≤–µ—á–∞–µ–º –Ω–∞ callback, —á—Ç–æ–±—ã —É–±—Ä–∞—Ç—å —á–∞—Å–∏–∫–∏ —É —Å–æ–æ–±—â–µ–Ω–∏—è
    await c.answer()


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –≤—ã–±–æ—Ä–∞ –µ–¥–∏–Ω–∏—Ü—ã –∏ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
@router.callback_query(lambda c: c.data and c.data.startswith(CB_UNIT_PREFIX), InvoiceEditStates.field_input)
async def cb_select_unit(c: CallbackQuery, state: FSMContext):
    """
    –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤—ã–±–æ—Ä–∞ –µ–¥–∏–Ω–∏—Ü—ã –∏–∑–º–µ—Ä–µ–Ω–∏—è.
    """
    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –µ–¥–∏–Ω–∏—Ü—É –∏–∑–º–µ—Ä–µ–Ω–∏—è
    unit = c.data[len(CB_UNIT_PREFIX):]
    
    # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ —Å–æ—Å—Ç–æ—è–Ω–∏—è
    data = await state.get_data()
    selected_issue = data.get("selected_issue", {})
    invoice_data = data.get("invoice", {})
    positions = invoice_data.get("positions", [])
    
    # –ù–∞—Ö–æ–¥–∏–º –ø–æ–∑–∏—Ü–∏—é
    issue_idx = data.get("selected_issue_idx", 0)
    issues = data.get("current_issues", [])
    
    position_idx = selected_issue.get("index", 0) - 1
    
    if 0 <= position_idx < len(positions):
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Ç–∞—Ä—É—é –µ–¥–∏–Ω–∏—Ü—É –¥–ª—è –æ—Ç—á–µ—Ç–∞
        old_unit = positions[position_idx].get("unit", "")
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –µ–¥–∏–Ω–∏—Ü—É –∏–∑–º–µ—Ä–µ–Ω–∏—è
        positions[position_idx]["unit"] = unit
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç—å –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏
        product = selected_issue.get("product")
        if product and product.unit and unit != product.unit and is_compatible_unit(unit, product.unit):
            # –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –æ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏
            await state.update_data(
                conversion_from=unit,
                conversion_to=product.unit,
                position_idx=position_idx
            )
            
            # –°–æ–∑–¥–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è
            keyboard = InlineKeyboardMarkup(inline_keyboard=[
                [
                    InlineKeyboardButton(text="‚úÖ –î–∞", callback_data=f"{CB_CONVERT_PREFIX}yes"),
                    InlineKeyboardButton(text="‚ùå –ù–µ—Ç", callback_data=f"{CB_CONVERT_PREFIX}no")
                ]
            ])
            
            # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
            quantity = positions[position_idx].get("quantity", 0)
            
            msg = (
                f"–ï–¥–∏–Ω–∏—Ü–∞ –∏–∑–º–µ—Ä–µ–Ω–∏—è –∏–∑–º–µ–Ω–µ–Ω–∞ –Ω–∞ <b>{unit}</b>.\n\n"
                f"–¢–æ–≤–∞—Ä –≤ –±–∞–∑–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –µ–¥–∏–Ω–∏—Ü—É <b>{product.unit}</b>.\n"
                f"–•–æ—Ç–∏—Ç–µ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏–∑ {unit} –≤ {product.unit}?\n\n"
                f"–¢–µ–∫—É—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ: {quantity} {unit}"
            )
            
            await c.message.edit_text(msg, reply_markup=keyboard, parse_mode="HTML")
            await c.answer()
            return
        
        # –ï—Å–ª–∏ –Ω–µ—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –≤ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏, –ø—Ä–æ—Å—Ç–æ –æ–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ
        invoice_data["positions"] = positions
        await state.update_data(invoice=invoice_data)
        
        # –î–æ–±–∞–≤–ª—è–µ–º –≤ —Å–ø–∏—Å–æ–∫ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã—Ö –ø–æ–∑–∏—Ü–∏–π
        fixed_issues = data.get("fixed_issues", {}) or {}
        fixed_issues[position_idx] = {
            "action": "change_unit",
            "old_unit": old_unit,
            "new_unit": unit
        }
        await state.update_data(fixed_issues=fixed_issues)
        
        # –ü–æ–ª—É—á–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫ –ø—Ä–æ–±–ª–µ–º
        current_issues = [issue for i, issue in enumerate(issues) if i != issue_idx]
        await state.update_data(current_issues=current_issues)
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å–ª–µ–¥—É—é—â–∏–π —à–∞–≥
        if not current_issues:
            # –ï—Å–ª–∏ –ø—Ä–æ–±–ª–µ–º –±–æ–ª—å—à–µ –Ω–µ—Ç, –ø–µ—Ä–µ—Ö–æ–¥–∏–º –∫ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—é
            await state.set_state(InvoiceEditStates.confirm)
            
            message, keyboard = await format_final_preview(
                invoice_data, 
                data.get("issues", []), 
                fixed_issues
            )
        else:
            # –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –∫ —Å–ø–∏—Å–∫—É –ø—Ä–æ–±–ª–µ–º
            await state.set_state(InvoiceEditStates.issue_list)
            
            message, keyboard = await format_issues_list(
                {"issues": current_issues}, 
                page=data.get("current_page", 0)
            )
            message = f"‚úÖ –ï–¥–∏–Ω–∏—Ü–∞ –∏–∑–º–µ—Ä–µ–Ω–∏—è –∏–∑–º–µ–Ω–µ–Ω–∞ –Ω–∞ <b>{unit}</b>.\n\n" + message
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
        try:
            await c.message.edit_text(message, reply_markup=keyboard, parse_mode="HTML")
        except Exception as e:
            logger.error("Failed to edit message", error=str(e))
            await c.message.answer(message, reply_markup=keyboard, parse_mode="HTML")
    else:
        await c.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –µ–¥–∏–Ω–∏—Ü—ã –∏–∑–º–µ—Ä–µ–Ω–∏—è.")
    
    await c.answer()


@router.callback_query(lambda c: c.data and c.data.startswith(CB_CONVERT_PREFIX))
async def cb_convert_unit(c: CallbackQuery, state: FSMContext):
    """
    –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ –µ–¥–∏–Ω–∏—Ü –∏–∑–º–µ—Ä–µ–Ω–∏—è.
    """
    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –æ—Ç–≤–µ—Ç
    action = c.data[len(CB_CONVERT_PREFIX):]
    is_auto = action == "auto"
    is_yes = action == "yes" or is_auto
    is_skip = action == "skip" or action == "no"
    
    # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ —Å–æ—Å—Ç–æ—è–Ω–∏—è
    data = await state.get_data()
    invoice_data = data.get("invoice", {})
    positions = invoice_data.get("positions", [])
    
    # –î–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ –ø–æ—Å–ª–µ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è
    if is_auto:
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è
        from_unit = data.get("from_unit", "")
        to_unit = data.get("to_unit", "")
        
        # –ù–∞—Ö–æ–¥–∏–º –ø–æ–∑–∏—Ü–∏—é –ø–æ match_id
        position_idx = None
        product_id = None
        
        for i, pos in enumerate(positions):
            if pos.get("match_id") and pos.get("unit") == from_unit:
                # –≠—Ç–æ –Ω–∞—à–∞ –ø–æ–∑–∏—Ü–∏—è
                position_idx = i
                product_id = pos.get("match_id")
                break
        
        if position_idx is None:
            await c.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –ø–æ–∑–∏—Ü–∏—é –¥–ª—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏.")
            return
    else:
        # –î–ª—è —Ä—É—á–Ω–æ–π –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
        from_unit = data.get("conversion_from", "")
        to_unit = data.get("conversion_to", "")
        position_idx = data.get("position_idx", -1)
    
    if 0 <= position_idx < len(positions):
        # –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø–æ–¥—Ç–≤–µ—Ä–¥–∏–ª –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—é
        if is_yes:
            quantity = positions[position_idx].get("quantity", 0)
            
            # –ü—ã—Ç–∞–µ–º—Å—è –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å
            try:
                quantity_float = float(quantity)
                converted = convert(quantity_float, from_unit, to_unit)
                
                if converted is not None:
                    # –û–±–Ω–æ–≤–ª—è–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏ –µ–¥–∏–Ω–∏—Ü—É
                    positions[position_idx]["quantity"] = converted
                    positions[position_idx]["unit"] = to_unit
                    
                    # –û–±–Ω–æ–≤–ª—è–µ–º —Å—É–º–º—É, –µ—Å–ª–∏ –µ—Å—Ç—å —Ü–µ–Ω–∞
                    if price := positions[position_idx].get("price"):
                        try:
                            price_float = float(price)
                            positions[position_idx]["sum"] = converted * price_float
                        except (ValueError, TypeError):
                            pass
                    
                    # –î–æ–±–∞–≤–ª—è–µ–º –≤ —Å–ø–∏—Å–æ–∫ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã—Ö –ø–æ–∑–∏—Ü–∏–π
                    fixed_issues = data.get("fixed_issues", {}) or {}
                    fixed_issues[position_idx] = {
                        "action": "convert_unit",
                        "from_unit": from_unit,
                        "to_unit": to_unit,
                        "old_quantity": quantity,
                        "new_quantity": converted
                    }
                    
                    await state.update_data(fixed_issues=fixed_issues)
                    
                    # –õ–æ–≥–∏—Ä—É–µ–º –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—é
                    try:
                        invoice_id = invoice_data.get("id", 0)
                        user_id = c.from_user.id if c.from_user else 0
                        
                        await log_change(
                            invoice_id=invoice_id,
                            row_idx=position_idx,
                            user_id=user_id,
                            field="convert_unit",
                            old=f"{quantity} {from_unit}",
                            new=f"{converted} {to_unit}"
                        )
                    except Exception as e:
                        logger.error("Failed to log unit conversion", error=str(e))
                    
                    # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± —É—Å–ø–µ—à–Ω–æ–π –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏
                    conversion_message = f"‚úÖ –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ: {quantity} {from_unit} ‚Üí {converted} {to_unit}"
                else:
                    # –ï—Å–ª–∏ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –Ω–µ–≤–æ–∑–º–æ–∂–Ω–∞
                    msg = (
                        f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –∏–∑ <b>{from_unit}</b> –≤ <b>{to_unit}</b>.\n"
                        f"–ï–¥–∏–Ω–∏—Ü–∞ –∏–∑–º–µ—Ä–µ–Ω–∏—è –∏–∑–º–µ–Ω–µ–Ω–∞, –Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—Å—Ç–∞–ª–æ—Å—å –ø—Ä–µ–∂–Ω–∏–º."
                    )
                    
                    keyboard = InlineKeyboardMarkup(inline_keyboard=[
                        [InlineKeyboardButton(text="‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data=CB_BACK)]
                    ])
                    
                    await c.message.edit_text(msg, reply_markup=keyboard, parse_mode="HTML")
                    await c.answer()
                    return
            except (ValueError, TypeError):
                # –û—à–∏–±–∫–∞ –ø—Ä–∏ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏
                msg = f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ, —á—Ç–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–¥–∞–Ω–æ —á–∏—Å–ª–æ–º."
                
                keyboard = InlineKeyboardMarkup(inline_keyboard=[
                    [InlineKeyboardButton(text="‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data=CB_BACK)]
                ])
                
                await c.message.edit_text(msg, reply_markup=keyboard, parse_mode="HTML")
                await c.answer()
                return
        elif is_skip:
            # –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –æ—Ç–∫–∞–∑–∞–ª—Å—è –æ—Ç –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏
            conversion_message = f"‚úÖ –ï–¥–∏–Ω–∏—Ü—ã –Ω–µ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã, –æ—Å—Ç–∞–≤–ª–µ–Ω–æ –∫–∞–∫ –µ—Å—Ç—å."
        else:
            await c.answer("‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ.")
            return
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏
        invoice_data["positions"] = positions
        await state.update_data(invoice=invoice_data)
        
        # –û–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫ –ø—Ä–æ–±–ª–µ–º
        issues = data.get("current_issues", [])
        issue_idx = None
        
        # –ù–∞—Ö–æ–¥–∏–º –∏–Ω–¥–µ–∫—Å –ø—Ä–æ–±–ª–µ–º—ã –≤ —Å–ø–∏—Å–∫–µ
        for i, issue in enumerate(issues):
            if issue.get("index", 0) - 1 == position_idx:
                issue_idx = i
                break
        
        if issue_idx is not None:
            current_issues = [issue for i, issue in enumerate(issues) if i != issue_idx]
            await state.update_data(current_issues=current_issues)
        else:
            current_issues = issues
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å–ª–µ–¥—É—é—â–∏–π —à–∞–≥
        if not current_issues:
            # –ï—Å–ª–∏ –ø—Ä–æ–±–ª–µ–º –±–æ–ª—å—à–µ –Ω–µ—Ç, –ø–µ—Ä–µ—Ö–æ–¥–∏–º –∫ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—é
            await state.set_state(InvoiceEditStates.confirm)
            
            message, keyboard = await format_final_preview(
                invoice_data, 
                data.get("issues", []), 
                data.get("fixed_issues", {})
            )
            message = f"{conversion_message}\n\n" + message
        else:
            # –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –∫ —Å–ø–∏—Å–∫—É –ø—Ä–æ–±–ª–µ–º
            await state.set_state(InvoiceEditStates.issue_list)
            
            message, keyboard = await format_issues_list(
                {"issues": current_issues}, 
                page=data.get("current_page", 0)
            )
            message = f"{conversion_message}\n\n" + message
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
        try:
            await c.message.edit_text(message, reply_markup=keyboard, parse_mode="HTML")
        except Exception as e:
            logger.error("Failed to edit message", error=str(e))
            await c.message.answer(message, reply_markup=keyboard, parse_mode="HTML")
    else:
        await c.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø–æ–∑–∏—Ü–∏–∏.")
    
    await c.answer()

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –ú–∞—Å—Å–æ–≤—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –∏ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
@router.callback_query(Text(CB_ADD_ALL))
async def cb_add_all_missing(c: CallbackQuery, state: FSMContext):
    """
    –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ "–î–æ–±–∞–≤–∏—Ç—å –≤—Å–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏–µ —Ç–æ–≤–∞—Ä—ã".
    """
    # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ —Å–æ—Å—Ç–æ—è–Ω–∏—è
    data = await state.get_data()
    invoice_data = data.get("invoice", {})
    positions = invoice_data.get("positions", [])
    issues = data.get("current_issues", [])
    
    # –ù–∞—Ö–æ–¥–∏–º –≤—Å–µ –ø–æ–∑–∏—Ü–∏–∏, –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏–µ –≤ –±–∞–∑–µ
    missing_positions = []
    for issue in issues:
        if "Not in database" in issue.get("issue", ""):
            position_idx = issue.get("index", 0) - 1
            if 0 <= position_idx < len(positions):
                missing_positions.append((position_idx, issue))
    
    if not missing_positions:
        await c.answer("‚ùå –ù–µ—Ç –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏—Ö –≤ –±–∞–∑–µ —Ç–æ–≤–∞—Ä–æ–≤.")
        return
    
    # –û—Ç–º–µ—á–∞–µ–º –≤—Å–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –∫–∞–∫ "–Ω–æ–≤—ã–π —Ç–æ–≤–∞—Ä"
    fixed_issues = data.get("fixed_issues", {}) or {}
    
    for position_idx, issue in missing_positions:
        fixed_issues[position_idx] = {"action": "new_product"}
        
        # –õ–æ–≥–∏—Ä—É–µ–º —Å–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ —Ç–æ–≤–∞—Ä–∞
        try:
            invoice_id = invoice_data.get("id", 0)
            user_id = c.from_user.id if c.from_user else 0
            item_name = positions[position_idx].get("name", "")
            
            await log_save_new(
                invoice_id=invoice_id,
                row_idx=position_idx,
                user_id=user_id,
                item_name=item_name
            )
        except Exception as e:
            logger.error("Failed to log add_all_missing action", error=str(e))
    
    # –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏
    await state.update_data(fixed_issues=fixed_issues)
    
    # –û–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫ –ø—Ä–æ–±–ª–µ–º (—É–¥–∞–ª—è–µ–º –≤—Å–µ —Ä–µ—à–µ–Ω–Ω—ã–µ)
    remaining_issues = []
    for issue in issues:
        if "Not in database" not in issue.get("issue", ""):
            remaining_issues.append(issue)
    
    await state.update_data(current_issues=remaining_issues)
    
    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å–ª–µ–¥—É—é—â–∏–π —à–∞–≥
    if not remaining_issues:
        # –ï—Å–ª–∏ –ø—Ä–æ–±–ª–µ–º –±–æ–ª—å—à–µ –Ω–µ—Ç, –ø–µ—Ä–µ—Ö–æ–¥–∏–º –∫ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—é
        await state.set_state(InvoiceEditStates.confirm)
        
        message, keyboard = await format_final_preview(
            invoice_data, 
            data.get("issues", []), 
            fixed_issues
        )
        
        # –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≥—Ä—É–ø–ø–æ–≤–æ–º –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏
        message = (
            f"‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–æ {len(missing_positions)} –Ω–æ–≤—ã—Ö —Ç–æ–≤–∞—Ä–æ–≤.\n\n"
            + message
        )
    else:
        # –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –∫ —Å–ø–∏—Å–∫—É –ø—Ä–æ–±–ª–µ–º
        await state.set_state(InvoiceEditStates.issue_list)
        
        message, keyboard = await format_issues_list(
            {"issues": remaining_issues}, 
            page=0
        )
        
        # –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≥—Ä—É–ø–ø–æ–≤–æ–º –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏
        message = (
            f"‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–æ {len(missing_positions)} –Ω–æ–≤—ã—Ö —Ç–æ–≤–∞—Ä–æ–≤.\n\n"
            + message
        )
    
    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
    try:
        await c.message.edit_text(message, reply_markup=keyboard, parse_mode="HTML")
    except Exception as e:
        logger.error("Failed to edit message", error=str(e))
        await c.message.answer(message, reply_markup=keyboard, parse_mode="HTML")
    
    await c.answer()


@router.callback_query(Text([CB_CONFIRM, "done"]))
async def cb_done(c: CallbackQuery, state: FSMContext):
    """
    –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ "–ì–æ—Ç–æ–≤–æ" - –ø–µ—Ä–µ—Ö–æ–¥ –∫ —Ñ–∏–Ω–∞–ª—å–Ω–æ–º—É –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—é.
    """
    # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ —Å–æ—Å—Ç–æ—è–Ω–∏—è
    data = await state.get_data()
    invoice_data = data.get("invoice", {})
    fixed_issues = data.get("fixed_issues", {})
    
    # –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—é
    await state.set_state(InvoiceEditStates.confirm)
    
    # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
    message, keyboard = await format_final_preview(
        invoice_data, 
        data.get("issues", []),
        fixed_issues
    )
    
    try:
        await c.message.edit_text(message, reply_markup=keyboard, parse_mode="HTML")
    except Exception as e:
        logger.error("Failed to edit message", error=str(e))
        await c.message.answer(message, reply_markup=keyboard, parse_mode="HTML")
    
    await c.answer()


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –ø–æ–∏—Å–∫–∞ —Ç–æ–≤–∞—Ä–∞ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
@router.callback_query(Text(CB_SEARCH), InvoiceEditStates.product_select)
async def cb_search_product(c: CallbackQuery, state: FSMContext):
    """
    –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ –ø–æ–∏—Å–∫–∞ —Ç–æ–≤–∞—Ä–∞.
    """
    # –ü–µ—Ä–µ—Ö–æ–¥–∏–º –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –≤–≤–æ–¥–∞ –ø–æ–∏—Å–∫–æ–≤–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞
    await state.update_data(field="search")
    await state.set_state(InvoiceEditStates.field_input)
    
    msg = "üîç –í–≤–µ–¥–∏—Ç–µ —á–∞—Å—Ç—å –Ω–∞–∑–≤–∞–Ω–∏—è —Ç–æ–≤–∞—Ä–∞ –¥–ª—è –ø–æ–∏—Å–∫–∞:"
    
    await c.message.edit_text(msg, parse_mode="HTML")
    
    await c.answer()


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –≤–≤–æ–¥–∞ —Ç–µ–∫—Å—Ç–∞ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
@router.message(InvoiceEditStates.field_input)
async def process_field_input(message: Message, state: FSMContext):
    """
    –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤–≤–æ–¥–∞ –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è –ø–æ–ª—è (–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ, –ø–æ–∏—Å–∫–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å).
    """
    # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ —Å–æ—Å—Ç–æ—è–Ω–∏—è
    data = await state.get_data()
    field = data.get("field", "")
    
    if field == "quantity":
        # –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–≤–æ–¥–∞ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞
        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≤–≤–µ–¥–µ–Ω–æ —á–∏—Å–ª–æ
            quantity_text = message.text.strip().replace(",", ".")
            quantity = float(quantity_text)
            
            # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏
            selected_issue = data.get("selected_issue", {})
            invoice_data = data.get("invoice", {})
            positions = invoice_data.get("positions", [])
            
            # –ù–∞—Ö–æ–¥–∏–º –ø–æ–∑–∏—Ü–∏—é –≤ —Å–ø–∏—Å–∫–µ –ø–æ–∑–∏—Ü–∏–π –Ω–∞–∫–ª–∞–¥–Ω–æ–π
            issue_idx = data.get("selected_issue_idx", 0)
            issues = data.get("current_issues", [])
            
            position_idx = selected_issue.get("index", 0) - 1
            
            if 0 <= position_idx < len(positions):
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Ç–∞—Ä–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
                old_quantity = positions[position_idx].get("quantity", 0)
                
                # –û–±–Ω–æ–≤–ª—è–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ
                positions[position_idx]["quantity"] = quantity
                
                # –û–±–Ω–æ–≤–ª—è–µ–º —Å—É–º–º—É, –µ—Å–ª–∏ –µ—Å—Ç—å —Ü–µ–Ω–∞
                if price := positions[position_idx].get("price"):
                    try:
                        price_float = float(price)
                        positions[position_idx]["sum"] = quantity * price_float
                    except (ValueError, TypeError):
                        pass
                
                # –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏
                invoice_data["positions"] = positions
                await state.update_data(invoice=invoice_data)
                
                # –õ–æ–≥–∏—Ä—É–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏–µ
                try:
                    invoice_id = invoice_data.get("id", 0)
                    user_id = message.from_user.id if message.from_user else 0
                    
                    await log_change(
                        invoice_id=invoice_id,
                        row_idx=position_idx,
                        user_id=user_id,
                        field="quantity",
                        old=old_quantity,
                        new=quantity
                    )
                except Exception as e:
                    logger.error("Failed to log quantity change", error=str(e))
                
                # –î–æ–±–∞–≤–ª—è–µ–º –≤ —Å–ø–∏—Å–æ–∫ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã—Ö –ø–æ–∑–∏—Ü–∏–π
                fixed_issues = data.get("fixed_issues", {}) or {}
                fixed_issues[position_idx] = {
                    "action": "change_quantity",
                    "old_quantity": old_quantity,
                    "new_quantity": quantity
                }
                await state.update_data(fixed_issues=fixed_issues)
                
                # –£–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (—á—Ç–æ–±—ã –Ω–µ –∑–∞—Å–æ—Ä—è—Ç—å —á–∞—Ç)
                try:
                    await message.delete()
                except Exception:
                    pass
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –¥—Ä—É–≥–∏–µ –ø—Ä–æ–±–ª–µ–º—ã —Å —ç—Ç–æ–π –ø–æ–∑–∏—Ü–∏–µ–π
                has_other_issues = False
                for issue in issues:
                    if issue.get("index", 0) - 1 == position_idx and issues.index(issue) != issue_idx:
                        has_other_issues = True
                        selected_issue = issue
                        await state.update_data(
                            selected_issue=issue, 
                            selected_issue_idx=issues.index(issue)
                        )
                        break
                
                # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å–ª–µ–¥—É—é—â–∏–π —à–∞–≥
                current_issues = issues
                if not has_other_issues:
                    current_issues = [issue for i, issue in enumerate(issues) if i != issue_idx]
                    await state.update_data(current_issues=current_issues)
                
                if not current_issues:
                    # –ï—Å–ª–∏ –ø—Ä–æ–±–ª–µ–º –±–æ–ª—å—à–µ –Ω–µ—Ç, –ø–µ—Ä–µ—Ö–æ–¥–∏–º –∫ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—é
                    await state.set_state(InvoiceEditStates.confirm)
                    
                    message_text, keyboard = await format_final_preview(
                        invoice_data, 
                        data.get("issues", []),
                        fixed_issues
                    )
                    
                    await message.answer(message_text, reply_markup=keyboard, parse_mode="HTML")
                elif has_other_issues:
                    # –ï—Å–ª–∏ –µ—Å—Ç—å –¥—Ä—É–≥–∏–µ –ø—Ä–æ–±–ª–µ–º—ã —Å —ç—Ç–æ–π –ø–æ–∑–∏—Ü–∏–µ–π
                    await state.set_state(InvoiceEditStates.issue_edit)
                    
                    message_text, keyboard = await format_issue_edit(selected_issue)
                    message_text = f"‚úÖ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏–∑–º–µ–Ω–µ–Ω–æ –Ω–∞ {quantity}.\n\n" + message_text
                    
                    await message.answer(message_text, reply_markup=keyboard, parse_mode="HTML")
                else:
                    # –ï—Å–ª–∏ –µ—Å—Ç—å –µ—â–µ –ø—Ä–æ–±–ª–µ–º—ã, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –∫ —Å–ø–∏—Å–∫—É
                    await state.set_state(InvoiceEditStates.issue_list)
                    
                    message_text, keyboard = await format_issues_list(
                        {"issues": current_issues}, 
                        page=data.get("current_page", 0)
                    )
                    message_text = f"‚úÖ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏–∑–º–µ–Ω–µ–Ω–æ –Ω–∞ {quantity}.\n\n" + message_text
                    
                    await message.answer(message_text, reply_markup=keyboard, parse_mode="HTML")
            else:
                await message.reply("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø–æ–∑–∏—Ü–∏–∏.")
        except ValueError:
            await message.reply(
                "‚ùå –í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ —á–∏—Å–ª–æ. –î—Ä–æ–±–Ω—ã–µ —á–∏—Å–ª–∞ –≤–≤–æ–¥–∏—Ç–µ —á–µ—Ä–µ–∑ —Ç–æ—á–∫—É, –Ω–∞–ø—Ä–∏–º–µ—Ä: 2.5"
            )
    
    elif field == "search":
        # –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–∏—Å–∫–æ–≤–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞
        search_query = message.text.strip()
        
        if len(search_query) < 2:
            await message.reply("–°–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π –∑–∞–ø—Ä–æ—Å. –í–≤–µ–¥–∏—Ç–µ –Ω–µ –º–µ–Ω–µ–µ 2 —Å–∏–º–≤–æ–ª–æ–≤.")
            return
        
        # –ò—â–µ–º —Ç–æ–≤–∞—Ä—ã –ø–æ –∑–∞–ø—Ä–æ—Å—É
        async with SessionLocal() as session:
            products = await get_products_by_name(session, search_query)
        
        # –£–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        try:
            await message.delete()
        except Exception:
            pass
        
        # –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –∫ –≤—ã–±–æ—Ä—É —Ç–æ–≤–∞—Ä–∞
        await state.set_state(InvoiceEditStates.product_select)
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–ø–∏—Å–æ–∫ —Ç–æ–≤–∞—Ä–æ–≤ –∏ –∑–∞–ø—Ä–æ—Å –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏
        await state.update_data(products=products, current_page=0, search_query=search_query)
        
        # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
        message_text, keyboard = await format_product_select(products, search_query, page=0)
        
        await message.answer(message_text, reply_markup=keyboard, parse_mode="HTML")
    
    elif field == "name":
        # –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–≤–æ–¥–∞ –∏–º–µ–Ω–∏
        new_name = message.text.strip()
        
        if not new_name:
            await message.reply("‚ùå –ò–º—è –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.")
            return
        
        if len(new_name) > 100:
            await message.reply("‚ùå –ò–º—è —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–æ–µ (–º–∞–∫—Å–∏–º—É–º 100 —Å–∏–º–≤–æ–ª–æ–≤).")
            return
        
        # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏
        selected_issue = data.get("selected_issue", {})
        invoice_data = data.get("invoice", {})
        positions = invoice_data.get("positions", [])
        
        # –ù–∞—Ö–æ–¥–∏–º –ø–æ–∑–∏—Ü–∏—é
        issue_idx = data.get("selected_issue_idx", 0)
        issues = data.get("current_issues", [])
        
        position_idx = selected_issue.get("index", 0) - 1
        
        if 0 <= position_idx < len(positions):
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Ç–∞—Ä–æ–µ –∏–º—è
            old_name = positions[position_idx].get("name", "")
            
            # –û–±–Ω–æ–≤–ª—è–µ–º –∏–º—è
            positions[position_idx]["name"] = new_name
            
            # –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏
            invoice_data["positions"] = positions
            await state.update_data(invoice=invoice_data)
            
            # –õ–æ–≥–∏—Ä—É–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏–µ
            try:
                invoice_id = invoice_data.get("id", 0)
                user_id = message.from_user.id if message.from_user else 0
                
                await log_change(
                    invoice_id=invoice_id,
                    row_idx=position_idx,
                    user_id=user_id,
                    field="name",
                    old=old_name,
                    new=new_name
                )
            except Exception as e:
                logger.error("Failed to log name change", error=str(e))
            
            # –î–æ–±–∞–≤–ª—è–µ–º –≤ —Å–ø–∏—Å–æ–∫ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã—Ö –ø–æ–∑–∏—Ü–∏–π
            fixed_issues = data.get("fixed_issues", {}) or {}
            fixed_issues[position_idx] = {
                "action": "change_name",
                "old_name": old_name,
                "new_name": new_name
            }
            await state.update_data(fixed_issues=fixed_issues)
            
            # –ü–æ–∏—Å–∫ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–π –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
            async with SessionLocal() as session:
                products = await get_products_by_name(session, new_name[:5], limit=5)
            
            # –ï—Å–ª–∏ –µ—Å—Ç—å –ø–æ–¥—Ö–æ–¥—è—â–∏–µ —Ç–æ–≤–∞—Ä—ã, –ø—Ä–µ–¥–ª–∞–≥–∞–µ–º –≤—ã–±—Ä–∞—Ç—å
            if products:
                await state.update_data(products=products, current_page=0, search_query=new_name[:5])
                await state.set_state(InvoiceEditStates.product_select)
                
                message_text, keyboard = await format_product_select(products, new_name[:5], page=0)
                message_text = f"‚úÖ –ò–º—è –∏–∑–º–µ–Ω–µ–Ω–æ –Ω–∞ <b>{new_name}</b>.\n\n–ù–∞–π–¥–µ–Ω–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö —Ç–æ–≤–∞—Ä–æ–≤:\n\n" + message_text
                
                await message.answer(message_text, reply_markup=keyboard, parse_mode="HTML")
            else:
                # –ï—Å–ª–∏ –Ω–µ—Ç —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–π, –ø—Ä–æ—Å—Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –∫ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—é
                await state.set_state(InvoiceEditStates.issue_edit)
                
                message_text, keyboard = await format_issue_edit(selected_issue)
                message_text = f"‚úÖ –ò–º—è –∏–∑–º–µ–Ω–µ–Ω–æ –Ω–∞ <b>{new_name}</b>.\n–°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–π –≤ –±–∞–∑–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.\n\n" + message_text
                
                await message.answer(message_text, reply_markup=keyboard, parse_mode="HTML")
        else:
            await message.reply("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –∏–º–µ–Ω–∏.")
    
    elif field == "unit":
        # –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–≤–æ–¥–∞ –µ–¥–∏–Ω–∏—Ü—ã –∏–∑–º–µ—Ä–µ–Ω–∏—è
        new_unit = message.text.strip()
        
        if not new_unit:
            await message.reply("‚ùå –ï–¥–∏–Ω–∏—Ü–∞ –∏–∑–º–µ—Ä–µ–Ω–∏—è –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç–æ–π.")
            return
        
        # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏
        selected_issue = data.get("selected_issue", {})
        invoice_data = data.get("invoice", {})
        positions = invoice_data.get("positions", [])
        
        # –ù–∞—Ö–æ–¥–∏–º –ø–æ–∑–∏—Ü–∏—é
        issue_idx = data.get("selected_issue_idx", 0)
        issues = data.get("current_issues", [])
        
        position_idx = selected_issue.get("index", 0) - 1
        
        if 0 <= position_idx < len(positions):
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Ç–∞—Ä—É—é –µ–¥–∏–Ω–∏—Ü—É –∏–∑–º–µ—Ä–µ–Ω–∏—è
            old_unit = positions[position_idx].get("unit", "")
            
            # –û–±–Ω–æ–≤–ª—è–µ–º –µ–¥–∏–Ω–∏—Ü—É –∏–∑–º–µ—Ä–µ–Ω–∏—è
            positions[position_idx]["unit"] = new_unit
            
            # –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏
            invoice_data["positions"] = positions
            await state.update_data(invoice=invoice_data)
            
            # –õ–æ–≥–∏—Ä—É–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏–µ
            try:
                invoice_id = invoice_data.get("id", 0)
                user_id = message.from_user.id if message.from_user else 0
                
                await log_change(
                    invoice_id=invoice_id,
                    row_idx=position_idx,
                    user_id=user_id,
                    field="unit",
                    old=old_unit,
                    new=new_unit
                )
            except Exception as e:
                logger.error("Failed to log unit change", error=str(e))
            
            # –î–æ–±–∞–≤–ª—è–µ–º –≤ —Å–ø–∏—Å–æ–∫ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã—Ö –ø–æ–∑–∏—Ü–∏–π
            fixed_issues = data.get("fixed_issues", {}) or {}
            fixed_issues[position_idx] = {
                "action": "change_unit",
                "old_unit": old_unit,
                "new_unit": new_unit
            }
            await state.update_data(fixed_issues=fixed_issues)
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç—å –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ (–µ—Å–ª–∏ –µ—Å—Ç—å —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã–π —Ç–æ–≤–∞—Ä)
            product = selected_issue.get("product")
            
            if product and product.unit and new_unit != product.unit:
                # –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏
                # –°–æ–∑–¥–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –¥–ª—è –≤—ã–±–æ—Ä–∞ –¥–µ–π—Å—Ç–≤–∏—è
                keyboard = InlineKeyboardMarkup(inline_keyboard=[
                    [
                        InlineKeyboardButton(text="üîÑ –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å", 
                                            callback_data=f"{CB_CONVERT_PREFIX}yes"),
                        InlineKeyboardButton(text="‚úÖ –û—Å—Ç–∞–≤–∏—Ç—å –∫–∞–∫ –µ—Å—Ç—å", 
                                            callback_data=f"{CB_CONVERT_PREFIX}no")
                    ]
                ])
                
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏
                await state.update_data(
                    conversion_from=new_unit,
                    conversion_to=product.unit,
                    position_idx=position_idx
                )
                
                # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
                msg = (
                    f"‚úÖ –ï–¥–∏–Ω–∏—Ü–∞ –∏–∑–º–µ—Ä–µ–Ω–∏—è –∏–∑–º–µ–Ω–µ–Ω–∞ –Ω–∞ <b>{new_unit}</b>.\n\n"
                    f"‚ö†Ô∏è –≠—Ç–∞ –µ–¥–∏–Ω–∏—Ü–∞ –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è –æ—Ç –µ–¥–∏–Ω–∏—Ü—ã —Ç–æ–≤–∞—Ä–∞ –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö (<b>{product.unit}</b>).\n"
                    f"–•–æ—Ç–∏—Ç–µ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏–∑ {new_unit} –≤ {product.unit}?"
                )
                
                await message.answer(msg, reply_markup=keyboard, parse_mode="HTML")
                return
                
            # –ï—Å–ª–∏ –Ω–µ—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –≤ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –∫ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—é
            await state.set_state(InvoiceEditStates.issue_edit)
            
            message_text, keyboard = await format_issue_edit(selected_issue)
            message_text = f"‚úÖ –ï–¥–∏–Ω–∏—Ü–∞ –∏–∑–º–µ—Ä–µ–Ω–∏—è –∏–∑–º–µ–Ω–µ–Ω–∞ –Ω–∞ <b>{new_unit}</b>.\n\n" + message_text
            
            await message.answer(message_text, reply_markup=keyboard, parse_mode="HTML")
        else:
            await message.reply("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –µ–¥–∏–Ω–∏—Ü—ã –∏–∑–º–µ—Ä–µ–Ω–∏—è.")
    else:
        await message.reply(f"‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–µ –ø–æ–ª–µ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è: {field}")
